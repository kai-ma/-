# 目录

[toc]

### [简单](#简单)

[104. 二叉树的最大深度](#104-二叉树的最大深度)

**[543. 二叉树的直径](#543-二叉树的直径)**

[101. 对称二叉树](#101-对称二叉树)

### [中等](#中等)

[199. 二叉树的右视图](#199-二叉树的右视图) 最基础的BFS



## 简单

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

Difficulty: **简单**

与[剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)相同。


给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**  
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

```java
	public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
```



### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

Difficulty: **简单**

考察要点：使用全局变量


给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**  
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：**两结点之间的路径长度是以它们之间边的数目表示。

方法1：不使用全局变量。最大直径 = Math(包括root的最大直径，左子树的最大直径，右子树的最大直径)。

每个子树都要重复计算depth，时间复杂度O(NlogN)

```java
	public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int diaContainRoot = depth(root.left) + depth(root.right);
        int diaOfLeftSubTree = diameterOfBinaryTree(root.left);
        int diaOfRightSubTree = diameterOfBinaryTree(root.right);
        return Math.max(diaContainRoot, Math.max(diaOfLeftSubTree, diaOfRightSubTree));
    }

    public int depth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return 1 + Math.max(depth(root.left), depth(root.right));
    }
```

方法2：使用全局变量。递归的返回值是子树的最大深度，左右子树的最大深度+1与max去对比。如果有多返回值也可以不使用全局变量

```java
	int max = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return max;
    }

    private int dfs(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = dfs(root.left);
        int right = dfs(root.right);
        max = Math.max(max, left + right);
        return 1 + Math.max(left, right);
    }
```



拓展：全局变量方法的原理与更多应用
在这道题中，全局变量计算的是路径的最大值（max）。计算 max 的方式不是一次性求出来的，而是在二叉树遍历的过程中，每出现一个值，就把这个值和全局变量比较计算，算一个最大值。最终全局变量能得到全局的最大值。

实际上这利用了 max 的性质，max 是一种在线算法。简单来说，在线算法就是在计算的时候，所有的输入数据以“流”的形式一个个进来，算法每次只处理一条数据，不需要保存全部的数据。

除了 max 之外，sum、all 也都属于在线算法（all 指的是 x1 && x2 && ... && xn 这样的计算）。可以举几个其他的二叉树题目例子：

二叉树的坡度：563. Binary Tree Tilt（sum）
判断平衡二叉树：110. Balanced Binary Tree（all）
二叉树路径数字：129. Sum Root to Leaf Numbers（sum）



### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

Difficulty: **简单**	[543. 二叉树的直径](#543-二叉树的直径)能做出来，这道题就应该能做出来。


给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

**进阶：**

你可以运用递归和迭代两种方法解决这个问题吗？

方法1：递归。从root的左右子树开分，左对右，右对左。

```java
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isSymmetric(root.left, root.right);
    }

    public boolean isSymmetric(TreeNode t1, TreeNode t2) {
        if (t1 == null || t2 == null) {
            return t1 == null && t2 == null;
        }
        return t1.val == t2.val
                && isSymmetric(t1.right, t2.left) && isSymmetric(t1.left, t2.right);
    }
```

方法2：迭代

```java
	public boolean isSymmetric(TreeNode root) {
        if (root == null || (root.left == null && root.right == null)) {
            return true;
        }
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.add(root.left);
        queue.add(root.right);
        while (!queue.isEmpty()) {
            TreeNode left = queue.poll();
            TreeNode right = queue.poll();
            if (left == null && right == null) {
                continue;
            }
            if (left == null || right == null) {
                return false;
            }
            if (left.val != right.val) {
                return false;
            }
            queue.add(left.left);
            queue.add(right.right);
            queue.add(left.right);
            queue.add(right.left);
        }
        return true;
    }
```



## 中等

### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

Difficulty: **中等**


给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例:**

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

```java
 	public List<Integer> rightSideView(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        if (root == null) {
            return list;
        }
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
                if (i == size - 1) {
                    list.add(node.val);
                }
            }
        }
        return list;
    }
```