# 树

## 目录

### [树的递归](#树的递归)

​	[104. 二叉树的最大深度](#104-二叉树的最大深度)

​	**[543. 二叉树的直径](#543-二叉树的直径)**

​	[101. 对称二叉树](#101-对称二叉树)

### [BFS](#BFS)

​	[199. 二叉树的右视图](#199-二叉树的右视图)、[102. 二叉树的层序遍历](#102-二叉树的层序遍历)、[103. 二叉树的锯齿形层序遍历](#103-二叉树的锯齿形层序遍历)最基础的BFS

### [树的前中后序遍历](#树的前中后序遍历)

​	**[105. 从前序与中序遍历序列构造二叉树](#105-从前序与中序遍历序列构造二叉树)**、[106. 从中序与后序遍历序列构造二叉树](#106-从中序与后序遍历序列构造二叉树)







[toc]



## 树的递归

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

Difficulty: **简单**

与[剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)相同。


给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**  
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

```java
	public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
```



### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

Difficulty: **简单**

考察要点：使用全局变量


给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**  
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

**注意：**两结点之间的路径长度是以它们之间边的数目表示。

方法1：不使用全局变量。最大直径 = Math(包括root的最大直径，左子树的最大直径，右子树的最大直径)。

每个子树都要重复计算depth，时间复杂度O(NlogN)

```java
	public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int diaContainRoot = depth(root.left) + depth(root.right);
        int diaOfLeftSubTree = diameterOfBinaryTree(root.left);
        int diaOfRightSubTree = diameterOfBinaryTree(root.right);
        return Math.max(diaContainRoot, Math.max(diaOfLeftSubTree, diaOfRightSubTree));
    }

    public int depth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return 1 + Math.max(depth(root.left), depth(root.right));
    }
```

方法2：使用全局变量。递归的返回值是子树的最大深度，左右子树的最大深度+1与max去对比。如果有多返回值也可以不使用全局变量

```java
	int max = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return max;
    }

    private int dfs(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = dfs(root.left);
        int right = dfs(root.right);
        max = Math.max(max, left + right);
        return 1 + Math.max(left, right);
    }
```



拓展：全局变量方法的原理与更多应用
在这道题中，全局变量计算的是路径的最大值（max）。计算 max 的方式不是一次性求出来的，而是在二叉树遍历的过程中，每出现一个值，就把这个值和全局变量比较计算，算一个最大值。最终全局变量能得到全局的最大值。

实际上这利用了 max 的性质，max 是一种在线算法。简单来说，在线算法就是在计算的时候，所有的输入数据以“流”的形式一个个进来，算法每次只处理一条数据，不需要保存全部的数据。

除了 max 之外，sum、all 也都属于在线算法（all 指的是 x1 && x2 && ... && xn 这样的计算）。可以举几个其他的二叉树题目例子：

二叉树的坡度：563. Binary Tree Tilt（sum）
判断平衡二叉树：110. Balanced Binary Tree（all）
二叉树路径数字：129. Sum Root to Leaf Numbers（sum）



### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

Difficulty: **简单**	[543. 二叉树的直径](#543-二叉树的直径)能做出来，这道题就应该能做出来。


给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

**进阶：**

你可以运用递归和迭代两种方法解决这个问题吗？

方法1：递归。从root的左右子树开分，左对右，右对左。

```java
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isSymmetric(root.left, root.right);
    }

    public boolean isSymmetric(TreeNode t1, TreeNode t2) {
        if (t1 == null || t2 == null) {
            return t1 == null && t2 == null;
        }
        return t1.val == t2.val
                && isSymmetric(t1.right, t2.left) && isSymmetric(t1.left, t2.right);
    }
```

方法2：迭代

```java
	public boolean isSymmetric(TreeNode root) {
        if (root == null || (root.left == null && root.right == null)) {
            return true;
        }
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.add(root.left);
        queue.add(root.right);
        while (!queue.isEmpty()) {
            TreeNode left = queue.poll();
            TreeNode right = queue.poll();
            if (left == null && right == null) {
                continue;
            }
            if (left == null || right == null) {
                return false;
            }
            if (left.val != right.val) {
                return false;
            }
            queue.add(left.left);
            queue.add(right.right);
            queue.add(left.right);
            queue.add(right.left);
        }
        return true;
    }
```



## BFS

### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

Difficulty: **中等**


给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例:**

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

```java
 	public List<Integer> rightSideView(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        if (root == null) {
            return list;
        }
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
                if (i == size - 1) {
                    list.add(node.val);
                }
            }
        }
        return list;
    }
```



### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

Difficulty: **中等**


给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**示例：**  
二叉树：`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

解法同[199. 二叉树的右视图](#199-二叉树的右视图)，最基础的BFS。



### [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

Difficulty: **中等**


给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：  
给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回锯齿形层序遍历如下：

```
[
  [3],
  [20,9],
  [15,7]
]
```

解法同[199. 二叉树的右视图](#199-二叉树的右视图)、[102. 二叉树的层序遍历](#102-二叉树的层序遍历)，单数行add(val)，偶数行add(0, val)。



## 树的前中后序遍历

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

Difficulty: **中等**


根据一棵树的前序遍历与中序遍历构造二叉树。

**注意:**  
你可以假设树中没有重复的元素。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

**一般做法：**

以preorder起点为根节点，用根节点在inorder位置确定左右子树分界，**递归**传入左右子树的preorder数组和inorder数组，构造左右子树。不需要copy新的数组，只需要传入新的左右边界下标。

inorder数组左右边界很简单，preorder数组左右边界计算--利用数组大小相等。

```java
	private Map<Integer, Integer> map;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int preLen = preorder.length;
        int inLen = inorder.length;
        map = new HashMap<>(10);
        for (int i = 0; i < inLen; i++) {
            map.put(inorder[i], i);
        }
        return buildTree(preorder, 0, preLen - 1, 0, inLen - 1);
    }


    private TreeNode buildTree(int[] preorder, int pl, int pr, int il, int ir) {
        if (pl > pr || il > ir) {
            return null;
        }
        // 先序遍历的起点元素很重要
        int pivot = preorder[pl];
        TreeNode root = new TreeNode(pivot);
        int pivotIndex = map.get(pivot);
        root.left = buildTree(preorder, pl + 1, pivotIndex - il + pl,
                il, pivotIndex - 1);
        root.right = buildTree(preorder, pivotIndex - il + pl + 1, pr,
                pivotIndex + 1, ir);
        return root;
    }
```

**熟悉树遍历的本质：只需要维护一个全局变量的指针，先序+1，即可保持先序的根节点。**

```java
class Solution {
    int idx;
    Map<Integer, Integer> map;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        map = new HashMap<>();
        for(int i=0;i<inorder.length;i++){
            map.put(inorder[i],i);
        }
        return buildTree(preorder,0,preorder.length-1);
    }
    private TreeNode buildTree(int[] preorder, int left, int right){
        if(left>right) return null;
        TreeNode root = new TreeNode(preorder[idx]);
        int pivot = map.get(preorder[idx]);  //在left之前，就是先序遍历 先序+1
        idx++;
        root.left=buildTree(preorder,left,pivot-1);
        root.right=buildTree(preorder,pivot+1,right);
        return root;
    }
}
```



### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

Difficulty: **中等**


根据一棵树的中序遍历与后序遍历构造二叉树。

**注意:**  
你可以假设树中没有重复的元素。

例如，给出

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

与[105. 从前序与中序遍历序列构造二叉树](#105-从前序与中序遍历序列构造二叉树)基本一样，后序从右往左，作用和先序数组一样。

```java
一般做法：
    
```



### [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

Difficulty: **中等**


返回与给定的前序和后序遍历匹配的任何二叉树。

 `pre` 和 `post` 遍历中的值是不同的正整数。

**示例：**

```
输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

**提示：**

*   `1 <= pre.length == post.length <= 30`
*   `pre[]` 和 `post[]` 都是 `1, 2, ..., pre.length` 的排列
*   每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。

```

```

https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/kan-wo-jiu-gou-liao-san-chong-bian-li-fang-shi-g-2/





# Old

# 递归DFS/BFS

**特别注意：树的递归一般对left和right递归的结果进行讨论，后处理，然后再返回。**   
比如最简单情况：110题 
## 一.基础——瞬间想出答案
### 树的高度  -Ⅰ
lc104. Maximum Depth of Binary Tree (Easy)
```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return 1+Math.max(maxDepth(root.left), maxDepth(root.right));
}
```
<br/>

### 判断是否为对称树 -Ⅱ
lc101. Symmetric Tree (Easy)  
思路：直接递归
```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    return isSymmetric(root.left, root.right);
}

private boolean isSymmetric(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    if (t1.val != t2.val) return false;
    return isSymmetric(t1.left, t2.right) && isSymmetric(t1.right, t2.left);
}
```
<br/>

### 判断从根到叶子的路径和  -Ⅰ
lc112. path sum (Easy)    
判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。  
思路：直接递归  
**拓展题：437.** 统记路径和等于一个值的路径数量 -双递归   
```java
public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) return false;
    if (root.left == null && root.right == null && root.val == sum) return true;
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
}
```
<br/>  

### 翻转树 -Ⅰ
lc226. Invert Binary Tree (Easy)  
**思路：类似交换**
```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    TreeNode l = root.left;  // 后面的操作会改变 left 指针，因此先保存下来
    root.left = invertTree(root.right);
    root.right = invertTree(l);
    return root;
}
```
<br/>

### 平衡树 +Ⅱ
lc110. Balanced Binary Tree (Easy)    
判断输入是否为平衡树：左右子树高度差都小于等于 1  
**思路：递归左右讨论**
```java
private boolean result = true;
public boolean isBalanced(TreeNode root) {
    maxDepth(root);
    return result;
}

public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    if (Math.abs(l - r) > 1) result = false;
    return 1 + Math.max(l, r);
}
```
其实不需要使用成员变量：用一个正常遍历不会得到的特殊值-1来标记不平衡。
```java
public boolean isBalanced(TreeNode root) {
    return maxDepth(root)!=-1;
}

public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    int l = maxDepth(root.left);
    if(l==-1) return -1;
    int r = maxDepth(root.right);
    if(r==-1) return -1;
    if (Math.abs(l - r) > 1) result -1;
    return 1 + Math.max(l, r);
}
```
<br/>

### 左叶子结点的和  -Ⅱ
lc404. Sum of Left Leaves(Easy) [LeetCode](https://leetcode.com/problems/sum-of-left-leaves/)/[力扣](https://leetcode-cn.com/problems/sum-of-left-leaves/)
```
计算给定二叉树的所有左叶子之和。

示例：

    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```
思路：左右分情况讨论
```java
偷懒写法，递归的过程中不用管
class Solution {
    int sum=0;
    public int sumOfLeftLeaves(TreeNode root) {
        dfs(root);
        return sum;
    }
    private void dfs(TreeNode root){
        if(root==null) return;
        if(root.left!=null&&root.left.left==null&&root.left.right==null) sum+=root.left.val;
        dfs(root.left);
        dfs(root.right);
    }
}

比较好的写法：
public int sumOfLeftLeaves(TreeNode root) {
    if(root == null) return 0;
    int res = 0;
    if(root.left != null) {
        if(root.left.left == null && root.left.right == null) res += root.left.val;
        else res += sumOfLeftLeaves(root.left);
    }
    res += sumOfLeftLeaves(root.right);  
    return res;
}
```
思路2：把boolean left作为递归遍历函数的参数  这种思想很多题也会用到
```java
public int sumOfLeftLeaves(TreeNode root) {
        return sumOfLeftLeaves(root, false);
    }
    
private int sumOfLeftLeaves(TreeNode root, boolean isLeft) {
    if (root == null) return 0;
    if (root.left == null && root.right == null && isLeft) {
        return root.val;
    }
    return sumOfLeftLeaves(root.left, true) + sumOfLeftLeaves(root.right, false);
}
```
<br/>

### 根到叶子的最短路径 +Ⅱ
lc111. Minimum Depth of Binary Tree (Easy) [LeetCode](https://leetcode.com/problems/minimum-depth-of-binary-tree/)/[力扣](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
```
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度  2.
```
**思路：递归左右讨论**   左为0或右为0，直接把很多情况都考虑到了
```java
//重做的时候想太多，还是不能第一时间做出来 
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    int left = minDepth(root.left);
    int right = minDepth(root.right);
    if (left == 0 || right == 0) return left + right + 1;  //只返回叶子结点的
    return Math.min(left, right) + 1;
}

其中if (left == 0 || right == 0) return left + right + 1;
直接考虑到了三种情况：
left==0&&right==0即当前结点位叶子结点，返回1。 
left==0，返回right+1  
right==0 返回left+1
```
**思路2：BFS**  记录层级，break多重循环，同样也很简单
```java
public int minDepth(TreeNode root) {
    if(root==null) return 0;
    Queue<TreeNode> queue=new LinkedList<>();
    queue.add(root);
    int res=0;  //记录层数
    OUT:
    while(!queue.isEmpty()){
        res++;
        int size=queue.size();
        for(int i=0;i<size;i++){
            TreeNode node=queue.poll();
            if(node.left==null&&node.right==null) break OUT;
            if(node.left!=null) queue.add(node.left);
            if(node.right!=null) queue.add(node.right);
        }
    }
    return res;
}
```
<br/>

### 两节点间的最长路径 +Ⅱ
lc543. Diameter of Binary Tree (Easy)  [LeetCode](https://leetcode.com/problems/diameter-of-binary-tree/)/[力扣](https://leetcode-cn.com/problems/diameter-of-binary-tree/)  
**思路：递归左右讨论**：For every node, length of longest path which pass it = MaxDepth of its left subtree + MaxDepth of its right subtree.

```java
private int max = 0;
public int diameterOfBinaryTree(TreeNode root) {
    depth(root);
    return max;
}

private int depth(TreeNode root) {
    if (root == null) return 0;
    int leftDepth = depth(root.left);
    int rightDepth = depth(root.right);
    max = Math.max(max, leftDepth + rightDepth);
    return Math.max(leftDepth, rightDepth) + 1;
}
```
<br/>

### 合并两个二叉树  
lc617. Merge Two Binary Trees (Easy) +Ⅲ  
如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。  
思路：直接递归
```java
public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return null;  //这一句可以直接删掉
    if (t1 == null) return t2;
    if (t2 == null) return t1;
    TreeNode root = new TreeNode(t1.val + t2.val);
    root.left = mergeTrees(t1.left, t2.left);
    root.right = mergeTrees(t1.right, t2.right);
    return root;
}
```
思路2：迭代方法，要稍微复杂一些。用数组把两个Node绑定在一起
```java
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null)
            return t2;
        Stack < TreeNode[] > stack = new Stack < > ();
        stack.push(new TreeNode[] {t1, t2});
        while (!stack.isEmpty()) {
            TreeNode[] t = stack.pop();
            if (t[0] == null || t[1] == null) {  //t[0]==null是针对初始情况
                continue;
            }
            t[0].val += t[1].val;
            if (t[0].left == null) {
                t[0].left = t[1].left;
            } else {
                stack.push(new TreeNode[] {t[0].left, t[1].left});
            }
            if (t[0].right == null) {
                t[0].right = t[1].right;
            } else {
                stack.push(new TreeNode[] {t[0].right, t[1].right});
            }
        }
        return t1;
    }
```
<br/>

### 子树判断 双递归-Ⅱ,String方法+Ⅲ 
lc572. Subtree of Another Tree (Easy)   
**思路1：很直接的双递归** O(N^2)  
```java
public boolean isSubtree(TreeNode s, TreeNode t) {
    if (s == null) return false;
    return isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
}

private boolean isSubtreeWithRoot(TreeNode s, TreeNode t) {
    if (t == null && s == null) return true;
    if (t == null || s == null) return false;
    if (t.val != s.val) return false;
    return isSubtreeWithRoot(s.left, t.left) && isSubtreeWithRoot(s.right, t.right);
}
```
思路2：很难想到的O(N)方法：**转换成String**，用indexOf函数:
```java
public class Solution {
    HashSet < String > trees = new HashSet < > ();
    public boolean isSubtree(TreeNode s, TreeNode t) {
        String tree1 = preorder(s, true);
        String tree2 = preorder(t, true);
        return tree1.indexOf(tree2) >= 0;
    }
    public String preorder(TreeNode t, boolean left) { //用StringBuilder更快
        if (t == null) {
            if (left)
                return "lnull";
            else
                return "rnull";  
        }
        return "#"+t.val +preorder(t.left, true)+preorder(t.right, false);
    }
}
```
<br/>

### 找出二叉树中第二小的节点 +Ⅱ
lc671. Second Minimum Node In a Binary Tree (Easy)  
给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 找出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1。  

```java
public int findSecondMinimumValue(TreeNode root) {
    if (root == null) return -1;
    if (root.left == null && root.right == null) return -1;
    int l= root.left.val;
    int r = root.right.val;
    if (l == root.val) l = findSecondMinimumValue(root.left);  //只要找不到大于root.val的，都会返回-1.
    if (r == root.val) r = findSecondMinimumValue(root.right);
    if (l != -1 && r != -1) return Math.min(l, r);  //只要大于root中最小的。
    if (l != -1) return l;
    return r;
}

学习大神写法：
It takes full conditions mentioned in question:
1.a non-empty tree
2.consisting of nodes with the non-negative value
3.each node in this tree has exactly two or zero sub-node

public int findSecondMinimumValue(TreeNode root) {
        if(root.left == null) return -1;
        int l = root.left.val == root.val ? findSecondMinimumValue(root.left) : root.left.val;
        int r = root.right.val == root.val ? findSecondMinimumValue(root.right) : root.right.val;
        return l == -1 || r == -1 ? Math.max(l, r) : Math.min(l, r);  //Math.max(l,r)如果有一个非负，非负的是第二小的。如果两个都负，返回-1.
    }
```
<br/>

### 一棵树每层节点的平均数——标准BFS  -Ⅰ  
lc637. Average of Levels in Binary Tree (Easy)  
求每层节点平均值组成的list  
**思路：标准的BFS 用size控制层级**  
几乎一模一样的题：513. Find Bottom Left Tree Value(Medium)
```java
public List<Double> averageOfLevels(TreeNode root) {
    if(root==null) return null;
    List<Double> list=new ArrayList<>();
    Queue<TreeNode> queue=new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty()){
        int size=queue.size();
        double layerSum=0;
        for(int i=0;i<size;i++){
            TreeNode node=queue.poll();
            layerSum+=node.val;
            if(node.left!=null) queue.offer(node.left);
            if(node.right!=null) queue.offer(node.right);
        }
        list.add(layerSum/size);
    }
    return list;
}

学习一下别人写的DFS:
    class Node {
        double sum;
        int count;
        Node (double d, int c) {
            sum = d;
            count = c;
        }
    }
    public List<Double> averageOfLevels(TreeNode root) {
        List<Node> temp = new ArrayList<>();
        helper(root, temp, 0);
        List<Double> result = new LinkedList<>();
        for (int i = 0; i < temp.size(); i++) {
            result.add(temp.get(i).sum / temp.get(i).count);
        }
        return result;
    }
    public void helper(TreeNode root, List<Node> temp, int level) {
        if (root == null) return;
        if (level == temp.size()) {
            Node node = new Node((double)root.val, 1);
            temp.add(node);
        } else {
            temp.get(level).sum += root.val;
            temp.get(level).count++;
        }
        helper(root.left, temp, level + 1);
        helper(root.right, temp, level + 1);
    }
```
### 奇数层从左到右，偶数层从右到左遍历 
lc103. Binary Tree Zigzag Level Order Traversal (Medium) [LeetCode](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)/[力扣](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

思路：和上一题一样，标准的BFS遍历。用一个boolean来控制add(val,0)还是add(val)。  
注意每个ArrayList都要先初始化，再添加值。
```java
     public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> lists=new ArrayList<>();
        if(root==null) return lists;
        Queue<TreeNode> queue=new LinkedList<>();
        queue.add(root);
        boolean reverse=false;
        int layer=0;
        while(!queue.isEmpty()){
            int size=queue.size();
            lists.add(new ArrayList<Integer>());
            for(int i=0;i<size;i++){
                TreeNode node=queue.poll();
                if(reverse) lists.get(layer).add(0, node.val);  //是加入node.val 不是node
                else lists.get(layer).add(node.val);
                if(node.left!=null) queue.add(node.left);
                if(node.right!=null) queue.add(node.right);
            }
            layer++;
            reverse=!reverse;
        }
        return lists;
    }
```
## 二、较难题——反复看，学习最佳方法和最简洁code
### 统计路径和等于一个数的路径数量 回溯法+Ⅲ
lc437. Path Sum III (Easy)   
```
示例：
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```
路径不一定以 root 开头，也不一定以 leaf 结尾，但是必须连续。  
**思路：双递归 O(N^2)**  
```java
方法一：双递归 给每一个结点做DFS O(N^2)
    public int pathSum(TreeNode root, int sum) {
        if (root == null) return 0;
        int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
        return ret;
    }
    
    private int pathSumStartWithRoot(TreeNode root, int sum) {
        if (root == null) return 0;
        int ret = 0;
        if (root.val == sum) ret++;
        ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
        return ret;
    }
```
**思路二：回溯+hashmap**  O(N)  hashmap保留沿路和的个数，遍历过当前的子树之后要恢复。
```java
   public int pathSum(TreeNode root, int sum) {
        HashMap<Integer, Integer> preSum = new HashMap();
        preSum.put(0,1);
        return helper(root, 0, sum, preSum);
    }
    
    public int helper(TreeNode root, int currSum, int target, HashMap<Integer, Integer> preSum) {
        if (root == null) {
            return 0;
        }
        
        currSum += root.val;
        int res = preSum.getOrDefault(currSum - target, 0);
        preSum.put(currSum, preSum.getOrDefault(currSum, 0) + 1);
        
        res += helper(root.left, currSum, target, preSum) + helper(root.right, currSum, target, preSum);
        preSum.put(currSum, preSum.get(currSum) - 1);  //回溯
        return res;
    }
```

<br/>

### 间隔遍历

### lc337. 树状的打家劫舍 III  2020.2.4  ++Ⅲ  完全掌握改善过程    
337. House Robber III (Medium)
**递归+动态规划**    
```
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 
除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 
如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

示例 1:

输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/house-robber-iii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
可以通过3个方法不断递进解决问题：==我一个都没做出来 第一次见树的动态规划==  

- 解法1通过递归实现，虽然解决了问题，但是复杂度太高
- 解法2通过解决方法1中的重复子问题，实现了性能的百倍提升  相比于数组类的动态规划，树的动态规划需要用Map
- 解法3 直接省去了重复子问题，性能又提升了一步  

**Step I -- Think naively** 纯递归

At first glance, the problem exhibits the feature of "optimal substructure": if we want to rob maximum amount of money from current binary tree (rooted at root), we surely hope that we can do the same to its left and right subtrees.

So going along this line, let's define the function rob(root) which will return the maximum amount of money that we can rob for the binary tree rooted at root; the key now is to construct the solution to the original problem from solutions to its subproblems, i.e., how to get rob(root) from rob(root.left), rob(root.right), ... etc.

Apparently the analyses above suggest a recursive solution. And for recursion, it's always worthwhile figuring out the following two properties:

Termination condition: when do we know the answer to rob(root) without any calculation? Of course when the tree is empty ---- we've got nothing to rob so the amount of money is zero.

Recurrence relation: i.e., how to get rob(root) from rob(root.left), rob(root.right), ... etc. From the point of view of the tree root, there are only two scenarios at the end: root is robbed or is not. If it is, due to the constraint that "we cannot rob any two directly-linked houses", the next level of subtrees that are available would be the four "grandchild-subtrees" (root.left.left, root.left.right, root.right.left, root.right.right). However if root is not robbed, the next level of available subtrees would just be the two "child-subtrees" (root.left, root.right). We only need to choose the scenario which yields the larger amount of money.

Here is the program for the ideas above:
```java
public int rob(TreeNode root) {
    if (root == null) return 0;
    int val = 0;
    if (root.left != null) {
        val += rob(root.left.left) + rob(root.left.right);
    }
    if (root.right != null) {
        val += rob(root.right.left) + rob(root.right.right);
    }
    return Math.max(val + root.val, rob(root.left) + rob(root.right));
}
```
However the solution runs very slowly (1186 ms) and barely got accepted (the time complexity turns out to be exponential, see my comments below).

**Step II -- Think one step further**  如何重复利用已经算过的值 有的parent只有一个结点，不能用数组  ==用HashMap==

In step I, we only considered the aspect of "optimal substructure", but think little about the possibilities of overlapping of the subproblems. For example, to obtain rob(root), we need rob(root.left), rob(root.right), rob(root.left.left), rob(root.left.right), rob(root.right.left), rob(root.right.right); but to get rob(root.left), we also need rob(root.left.left), rob(root.left.right), similarly for rob(root.right). The naive solution above computed these subproblems repeatedly, which resulted in bad time performance. Now if you recall the two conditions for dynamic programming (DP): "optimal substructure" + "overlapping of subproblems", we actually have a DP problem. A naive way to implement DP here is to use a hash map to record the results for visited subtrees.

And here is the improved solution:  
已经遍历过的不重复计算。
```java
public int rob(TreeNode root) {
    return robSub(root, new HashMap<>());
}

private int robSub(TreeNode root, Map<TreeNode, Integer> map) {
    if (root == null) return 0;
    if (map.containsKey(root)) return map.get(root);  //已经遍历过
    
    int val = 0;
    
    if (root.left != null) {
        val += robSub(root.left.left, map) + robSub(root.left.right, map);
    }
    
    if (root.right != null) {
        val += robSub(root.right.left, map) + robSub(root.right.right, map);
    }
    
    val = Math.max(val + root.val, robSub(root.left, map) + robSub(root.right, map));
    map.put(root, val);
    
    return val;
}
```
The runtime is sharply reduced to 9 ms, at the expense of O(n) space cost (n is the total number of nodes; stack cost for recursion is not counted).

**Step III -- Think one step back**  

上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。  
我们换一种办法来定义此问题  
**无重复——每个节点可选择偷或者不偷两种状态**，根据题目意思，相连节点不能一起偷

当前节点选择偷时，那么两个孩子节点就不能选择偷了
当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)
我们使用一个大小为2的数组来表示 int[] res = new int[2] 0代表不偷，1代表偷
任何一个节点能偷到的最大钱的状态可以定义为

当前节点选择不偷: 当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱  
当前节点选择偷: 当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数  

表示为公式如下  
root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])  
root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;

In step I, we defined our problem as rob(root), which will yield the maximum amount of money that can be robbed of the binary tree rooted at root. This leads to the DP problem summarized in step II.

Now let's take one step back and ask why we have overlapping subproblems. If you trace all the way back to the beginning, you'll find the answer lies in the way how we have defined rob(root). As I mentioned, for each tree root, there are two scenarios: it is robbed or is not. rob(root) does not distinguish between these two cases, so "information is lost as the recursion goes deeper and deeper", which results in repeated subproblems.

If we were able to maintain the information about the two scenarios for each tree root, let's see how it plays out. Redefine rob(root) as a new function which will return an array of two elements, the first element of which denotes the maximum amount of money that can be robbed if root is not robbed, while the second element signifies the maximum amount of money robbed if it is robbed.

Let's relate rob(root) to rob(root.left) and rob(root.right)..., etc. For the 1st element of rob(root), we only need to sum up the larger elements of rob(root.left) and rob(root.right), respectively, since root is not robbed and we are free to rob its left and right subtrees. For the 2nd element of rob(root), however, we only need to add up the 1st elements of rob(root.left) and rob(root.right), respectively, plus the value robbed from root itself, since in this case it's guaranteed that we cannot rob the nodes of root.left and root.right.

As you can see, by keeping track of the information of both scenarios, we decoupled the subproblems and the solution essentially boiled down to a greedy one. Here is the program:
```java
public int rob(TreeNode root) {
    int[] res = robSub(root);
    return Math.max(res[0], res[1]);
}

private int[] robSub(TreeNode root) {
    if (root == null) return new int[2];
    
    int[] left = robSub(root.left);
    int[] right = robSub(root.right);
    int[] res = new int[2];

    res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    res[1] = root.val + left[0] + right[0];
    
    return res;
}
```
<br/>

### 最长同值路径  +Ⅲ
lc687. Longest Univalue Path(EASY)  
```
给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

注意：两个节点之间的路径长度由它们之间的边数表示。

示例:
输入:

              5
             / \
            4   5
           / \   \
          1   1   5
输出:2
```
**思路：递归后处理**   一模一样思路的还有下一道题，lc124.Binary Tree Maximum Path Sum(HARD)  
以某个节点为根节点的最长同值路径:left+right  
left: 如果该节点的值等于其左子树的值，则最长同值路径要加上左子树的最长同值路径，如果不等，以该节点为根的左子树的路径为0。
右子树相同  
然后由于是两个结点之间的路径，这一层作为上一层的left或者right，需要把本层left或right中的大值返回
```java
class Solution {
    int max = 0;
    public int longestUnivaluePath(TreeNode root) {
        helper(root);
        return max;
    }
    int helper(TreeNode root){
        if(root == null) return 0;
        
        int left = helper(root.left);
        int right = helper(root.right);
        
        left = (root.left != null && root.left.val == root.val) ? left + 1 : 0;
        right = (root.right != null && root.right.val == root.val) ? right + 1 : 0;
        
        max = Math.max(max, left + right);
        return Math.max(left, right);   //上面的left=helper(root.left) 只能选left左右中最长的一条路，继续往上推，算上面的
    }
}
```
### O(N)求二叉树中的最大路径和 +Ⅲ
lc124. Binary Tree Maximum Path Sum (Hard)  
和687思路一模一样 
```
给定一个非空二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

示例 1:
输入: [1,2,3]

       1
      / \
     2   3
输出: 6

示例 2:
输入: [-10,9,20,null,null,15,7]

  -10
   / \
  9  20
    /  \
   15   7
输出: 42
```

```java
class Solution {
    int sum=Integer.MIN_VALUE;  
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return sum;
    }
    private int dfs(TreeNode root){
        if(root==null) return 0;
        int left=Math.max(0,dfs(root.left));  //和0比较是为了排除左右是负数，可以不要左右
        int right=Math.max(0.dfs(root.right));
        sum=Math.max(sum, left+right+root.val);
        return root.val+Math.max(left, right);//为上一层返回子树的最大链路：不要忘记加root.val  
    }
}
```
<br/>

# 遍历
## 各种遍历的递归
二叉搜索树只是大小有限制，但和其他树的方法一样，会用到递归，或者BFS等。
### 98.判断是否为搜索二叉树——inOrder遍历
https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode/
```
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树
```
```java
    double pre = - Double.MAX_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root==null) return true;
        if(!isValidBST(root.left)) return false;
        if(root.val<=pre) return false;
        pre=root.val;
        if(!isValidBST(root.right)) return false;
        return true;
    }
```

## 用Stack模拟递归遍历
### Stack模拟的中序，前序，后续遍历  +Ⅲ 要求：秒写
lc94. Binary Tree Inorder Traversal (Medium)   
lc144. Binary Tree Preorder Traversal (Medium)  
lc145. Binary Tree Postorder Traversal (Hard)  
三道题的方法类似，会做一个，应该其他都会做了。  

思路：Stack和递归的本质相同，先入栈的后处理。不同的dfs顺序只是处理语句的位置不同，其余写法都一样。

1.中序遍历  
lc94. Binary Tree Inorder Traversal (Medium)  
```java
    dfs(root){
        dfs(root.left);
        list.add(root.val);
        dfs(root.right);
    }
    
    模拟递归：
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list=new ArrayList<>();
        Stack<TreeNode> stack=new Stack<>();
        while(root!=null||!stack.isEmpty()){   
            while(root!=null){   //相当于不断深入递归dfs(root.left);
                stack.push(root); //先加入的root，再加入的root.left  出栈先出root.left，再出root
                root=root.left;    
            }
            root=stack.pop();   
            list.add(root.val);   
            root=root.right;   //根root处理完之后，处理root.right，相当于dfs(root.right); 
        }   
        return list;
    }
    
    也可以把内部的while(root!=null){} 
    换成 if(root!=null){} else{}      一步一步处理
```
2.先序遍历，只需要把处理的顺序交换一下即可。把list.add()这一句提到最前面
```java
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list=new ArrayList<>();
        Stack<TreeNode> stack=new Stack<>();
        while(!stack.isEmpty()||root!=null){
            while(root!=null){
                list.add(root.val);
                stack.push(root);
                root=root.left;
            }
            root=stack.pop();  
            root=root.right;
        }
        return list;
    }
    
上面的方法是先处理，再push到stack中。    
还可以先push再处理的方法：这种的前序更好理解一点：
循环前先把root加入，然后pop出来的直接处理，然后先加入右，再加入左。对于相同root，先弹出left，再弹出right。
    public static void preOrderTraversal(TreeNode head) {
    	if (head == null) {
    		return;
    	}
    	Stack<TreeNode> stack = new Stack<>();
    	stack.push(head);
    	while (!stack.isEmpty()) {
    		TreeNode node = stack.pop();
    		System.out.print(node.value + " ");
    		if (node.right != null) {
    			stack.push(node.right);
    		}
    		if (node.left != null) {
    			stack.push(node.left);
    		}
    	}
    }
```

3.后续遍历  
lc145. Binary Tree Postorder Traversal (Hard)   
```
给定一个二叉树，返回它的后序遍历。

示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```
最难的一个，左右中，关键是当前pop出来的node不能直接丢掉，因为还要处理right，root最后才处理。  
很多人写的用到前序遍历，把左右反过来，然后reverse list，这只是题做对了，但实际上并不是后续遍历，如果需要后序做一些操作的时候，是错的。  

怎么应对root不能删呢？ 我想的用peek，写不出来，感觉需要用map记录一下是不是node的左右子树都遍历过了。 map<TreeNode,boolean> ? 用set就够了 

具体写不出来，参考力扣中文的@windliang的解答 https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--34/

windliang第一种方法就是用的peek，不过不需要用map，用set记录。  
当从左子树到根节点的时候，把节点加入到set中，之后就可以判断当前节点在不在set中，如果在的话就表明当前是第二次回来，也就意味着是从右子树到的根节点。

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    Set<TreeNode> set = new HashSet<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null && !set.contains(cur)) {
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.peek();
        //右子树为空或者第二次来到这里
        if (cur.right == null || set.contains(cur)) {
            list.add(cur.val);
            set.add(cur);
            stack.pop();//将当前节点弹出
            if (stack.isEmpty()) {
                return list;
            }
            //转到上层的右子树，这种情况对应于右子树为空的情况
            cur = stack.peek();
            cur = cur.right;
        //从左子树过来，加到 set 中，转到右子树
        } else {
            set.add(cur);
            cur = cur.right;
        }
    }
    return list;
}
```
第二种方法更简洁便于理解：  
上边的解法在判断当前是从左子树到的根节点还是右子树到的根节点用了set，这里还有一个更直接的方法，通过记录上一次遍历的节点。==**如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了。**==  
每次只处理一步，这样变量last含义更清晰一些。虽然内部用while也行
```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    TreeNode last = null;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode temp = stack.peek();
            //是否变到右子树
            if (temp.right != null && temp.right != last) {
                cur = temp.right;
            } else {  //已经遍历过左右了
                list.add(temp.val);
                last = temp;
                stack.pop();
            }
        }
    }
    return list;
}
```
第三种方法：把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。  
相同的话，就意味着是从左子树到的根节点。  
不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。  

实际上对于每个node，push两次，先push进去的那一次后pop出来，用于左右遍历结束之后对这个结点的处理。  
后push进去的那一次先pop出来，用于push左右结点，左右结点相比于node入栈更晚，先处理。
同时对于每个结点，先push右边的，再push左边的。  

这种push两个的思路有点像minStack的实现那道题。
```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if (root == null) {
        return list;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();
        if (cur == null) {
            continue;
        }
        if (!stack.isEmpty() && cur == stack.peek()) {
            stack.push(cur.right);  //先右再左
            stack.push(cur.right);
            stack.push(cur.left);
            stack.push(cur.left);
        } else {
            list.add(cur.val);
        }
    }
    return list;
}
```

todo 补充做过的tree和stack有关的题
## Morris遍历

# 二叉搜索树
二叉搜索树只是大小有限制，但和其他树的方法一样，会用到递归，或者BFS等。
### 98.判断是否为搜索二叉树——inOrder遍历
```
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树
```
```java
    double pre = - Double.MAX_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root==null) return true;
        if(!isValidBST(root.left)) return false;
        if(root.val<=pre) return false;
        pre=root.val;
        if(!isValidBST(root.right)) return false;
        return true;
    }
```

### 修剪二叉查找树
lc669. Trim a Binary Search Tree (Easy)  -Ⅱ  
只保留val在 [L ~ R] 之间的节点
思路：很简单的递归
```java
public TreeNode trimBST(TreeNode root, int L, int R) {
    if(root==null) return root;
    if(root.val<L) return trimBST(root.right, L, R);
    if(root.val>R) return trimBST(root.left,L, R);
    root.left=trimBST(root.left, L, R);
    root.right=trimBST(root.right, L, R);
    return root;
}
```
### 二叉搜索树中第K小的元素
lc230. Kth Smallest Element in a BST(Medium)  
找到二叉搜索树中第k小的元素。  
单纯这道题不难，但拓展很有意思，既是树又是链表。
```java
1.InOrder遍历
class Solution {
    int ret;
    int cnt;
    public void inorder(TreeNode root) {
        if(root==null||cnt<0) return;
        inorder(root.left);
        cnt--;
        if(cnt==0){
            ret=root.val;
            return;
        }
        inorder(root.right);
    }
    public int kthSmallest(TreeNode root, int k) {
        this.cnt=k;
        inorder(root);
        return ret;
    }
}

2.Stack的Iterative模拟InOrder递归
    public int kthSmallest(TreeNode root, int k) {
         Stack<TreeNode> stack = new Stack<TreeNode>();
         TreeNode p = root;
         while(!stack.isEmpty() || p != null) {
             while(p != null) {
                 stack.push(p);  // Just like recursion
                 p = p.left;   

             } 
                TreeNode node = stack.pop();
                if(--k==0) return node.val; 
                p = node.right;
         }
         return Integer.MIN_VALUE;
    }
```