### [二分法解题思路](#二分法解题思路)



### 基础二分

​	**[35. 搜索插入位置](#35-搜索插入位置)**

​		[74. 搜索二维矩阵](#74-搜索二维矩阵)

​	**[69. x 的平方根](#69-x的平方根)**

​	**[34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)**











## 二分法解题思路

二分查找的核心思想是**「减而治之」**，即**「不断缩小问题规模」**，排除不可能的区域，最终找到要查找的元素。

**基础二分推荐使用如下方法：**

- while(left < right) 
  退出循环的时候 left 和 right 重合，区间 [left, right] 只剩下成 1 个元素，无需考虑返回 left 还是 right。这个元素 **很有可能** 就是我们要找的元素。
- 考虑判断条件和下一轮搜索区间：根据某种判断条件，把区间分为 2 个部分，**一个部分肯定不存在目标元素**，另一个部分**有可能存在目标元素**。根据这种判断条件，留下有可能存在目标元素的区间。
  - **情况1：**若区间划分为：`[left, mid]` 与 `[mid + 1, right]` ，mid 被分到左边，对应 `int mid = left + (right - left) / 2;`
  - **情况2：**若区间划分为：`[left, mid - 1]` 与 `[mid, right]` ，mid 被分到右边，对应 `int mid = left + (right - left + 1) / 2;`
  - 至于为什么划分是这种对应关系，原因在于区间只有 2 个数的时候，如果中间数的取法不对，一旦进入的分支不能使得区间缩小，会出现死循环。暂时不理解问题不大，需要在练习中进行调试；
  - **每次做题时，试一下区间只有2个数时，会不会出现死循环。**

- 退出循环的时候有 `left == right` 成立，此时如果能确定问题一定有解，返回 `left` 即可，如果不能确定，需要单独判断一次，可能就是前一个或者后一个，即`left - 1` 或 `left + 1`。



## 基础二分

### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

Difficulty: **简单**


给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2:**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```

**思路：二分法**。 如果`nums[mid] < target`，要找的位置还在右边，可能区间为`[mid + 1, right]`，选用区间划分情况1，`int mid = left + (right - left) / 2;`

```java
	public int searchInsert(int[] nums, int target) {
        //先排除特殊情况
        if (nums.length == 0 || target > nums[nums.length - 1]) {
            return nums.length;
        }
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            //如果当前值小于目标值，目标值在[mid + 1, right]区间
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                //如果当前值大于等于目标值，目标值可能在[left, mid]区间
                right = mid;
            }
        }
        return left;
    }
```

**相关高频题：**

[74. 搜索二维矩阵](#74-搜索二维矩阵)

**[69. x 的平方根](#69-x的平方根)**

**[34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)**

其他相似题：

​	[278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/) 几乎是一样的





### [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

Difficulty: **中等**


编写一个高效的算法来判断 `m x n` 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

*   每行中的整数从左到右按升序排列。
*   每行的第一个整数大于前一行的最后一个整数。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

**提示：**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= m, n <= 100`
*   -10<sup>4</sup> <= matrix\[i][j], target <= 10<sup>4</sup>

**思路：实际上可以当成一维有序数组做。这样和[35. 搜索插入位置](#35-搜索插入位置)相同，退出while循环后判断，插入位置不等于target，返回false。**

```java
	public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int r = matrix.length;
        int c = matrix[0].length;
        int left = 0;
        int right = r * c - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (target > matrix[mid / c][mid % c]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return matrix[left / c][left % c] == target;
    }
```



### [69. x的平方根](https://leetcode-cn.com/problems/sqrtx/)

Difficulty: **简单**


实现 `int sqrt(int x)` 函数。

计算并返回 _x_ 的平方根，其中 _x_ 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 1:**

```
输入: 4
输出: 2
```

**示例 2:**

```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```

**思路：二分法**。 如果`mid * mid > x`，可能区间为`[left, mid - 1]`，选用区间划分情况2，`int mid = left + (right - left + 1) / 2;`

```java
	public int mySqrt(int x) {
        if (x <= 1) {
            return x;
        }
        int left = 1;
        int right = x;
        while (left < right) {
            int mid = left + (right - left + 1) / 2;
            if (mid > x / mid) {
                //target在[left,right-1]内
                right = mid - 1;  
            } else {
                //target在[mid,right]内，可能是mid
                left = mid;  
            }
        }
        return left;
    }
```

**相关高频题：**

**[35. 搜索插入位置](#35-搜索插入位置)**

**[34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)**



### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

Difficulty: **中等**


给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

**进阶：**

*   你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

**提示：**

*   0 <= nums.length <= 10<sup>5</sup>
*   -10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>
*   `nums` 是一个非递减数组
*   -10<sup>9</sup> <= target <= 10<sup>9</sup>

**方法1：结合[35. 搜索插入位置](#35-搜索插入位置)、[69. x 的平方根](#69-x的平方根)，很容易做出来。**

- 找第一个的时候，等于的情况向左走，下一轮搜索区间是[left, mid]，属于区间分类情况1，用`int mid = left + (right - left) / 2;`。
- 找最后一个的时候，等于的情况向右走，下一轮搜索区间是 [mid, right]，属于区间分类情况2，用`int mid = left + (right - left + 1) / 2;`

**方法2：观察方法1，只有`nums[mid] == target`的时候，才有不同，其余代码都是重复的。**可以把重复提取出来，传入一个boolean变量来表示找第一个还是找最后一个。注意判断特殊情况

```java
	public int[] searchRange(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return new int[]{-1, -1};
        }
        int firstPosition = findFirstPosition(nums, target);
        if (firstPosition == -1) {
            return new int[]{-1, -1};
        }
        int lastPosition = findLastPosition(nums, target);
        return new int[]{firstPosition, lastPosition};
    }

    private int findFirstPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // 下一轮搜索区间是 [left, mid]
                right = mid;
            }else if (nums[mid] > target) {
                // 大于target一定不是解，下一轮搜索区间是 [left, mid - 1]
                right = mid - 1;
            } else {
                // 小于target一定不是解，下一轮搜索区间是 [mid + 1, right]
                left = mid + 1;
            }
        }
		//需要判断最终left处是不是target
        if (nums[left] == target) {
            return left;
        }
        return -1;
    }

    private int findLastPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left + 1) / 2;
            if (nums[mid] == target) {
                // 下一轮搜索区间是 [mid, right]
                left = mid;
            }else if (nums[mid] > target) {
                // 大于target一定不是解，下一轮搜索区间是 [left, mid - 1]
                right = mid - 1;
            } else {
                // 小于target一定不是解，下一轮搜索区间是 [mid + 1, right]
                left = mid + 1;
            }
        }
        //经过findFirstPosition，一定有相等的，所以直接返回即可。
        return left;
    }
```

方法2：

```java
	public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) {
            return new int[]{-1, -1};
        }
        int[] res = new int[2];
        res[0] = search(nums, target, true);
        res[1] = search(nums, target, false);
        return res;
    }

    private int search(int[] nums, int target, boolean isleft) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) >> 1;
            //如果求最右边的一个，相等的话，在[mid + 1, right]中寻找。最终如果存在，会停在left - 1
            if (nums[mid] < target || (!isleft && nums[mid] == target)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if (nums[left] == target) {
            return left;
        } else if (left - 1 >= 0 && nums[left - 1] == target) {
            return left - 1;  //不加判断：[2,2]  1 出错
        } else {
            return -1;
        }
    }
```









## Todo

[题解](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)中的题