[121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)

​	[122. 买卖股票的最佳时机(二)](#122-买卖股票的最佳时机(二))



### 子序列\子数组问题

**[300. 最长递增子序列](#300-最长递增子序列)**



### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**相同题：[剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)**

Difficulty: **简单**


给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

*   1 <= prices.length <= 10<sup>5</sup>
*   0 <= prices[i] <= 10<sup>4</sup>

**思路1：动态规划。**dp[i] 表示前i天的最大利润，则：`dp[i] = max(dp[i-1], prices[i]-minprice)`，minprice是从0到i-1的最小价格。

**思路2：贪心法。对于任意第i天，如果在这一天卖股票，在这一天的最大收益 `maxprofit =  price[i] - 从起始到i-1处的最小价格`。**每一天都计算这一天的maxprofit，并去更新最大收益，最终即可得到最大收益。

方法2其实是方法1的空间优化方法。

```java
	//方法1，动态规划。
	public int maxProfit(int[] prices) {
        int minprice = prices[0];
        int[] dp = new int[prices.length];
        for (int i = 1; i < prices.length; i++){
            minprice = Math.min(minprice, prices[i]);
            dp[i] = Math.max(dp[i - 1], prices[i] - minprice);
        }
        return dp[prices.length - 1];
    }

	//方法2：贪心法
	public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
```



### [122. 买卖股票的最佳时机(二)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

Difficulty: **简单**


给定一个数组，它的第 _i_ 个元素是一支给定股票第 _i_ 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

*   `1 <= prices.length <= 3 * 10 ^ 4`
*   `0 <= prices[i] <= 10 ^ 4`

**思路1：动态规划。**用两个数组，cash[i]表示当前持有现金时的最大收益，hold[i]表示当前持有股票时的最大收益。遍历数组不断更新即可。

![image.png](https://pic.leetcode-cn.com/041a4d01398359409ecc69dacc13a44d179dd1a2a9f43b1def80e9a6acceee55-image.png)

```java
	public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len <= 1) {
            return 0;
        }

        // cash：持有现金
        // stock：持有股票
        // 状态数组
        // 状态转移：cash → stock → cash → stock → cash → stock → cash
        int[] cash = new int[len];
        int[] stock = new int[len];

        cash[0] = 0;
        stock[0] = -prices[0];

        for (int i = 1; i < len; i++) {
            // 这两行调换顺序也是可以的
            cash[i] = Math.max(cash[i - 1], stock[i - 1] + prices[i]);
            stock[i] = Math.max(stock[i - 1], cash[i - 1] - prices[i]);
        }
        return cash[len - 1];
    }
```

**思路2：贪心法——在每一步总是做出在当前看来最好的选择，只要比前一天高，就卖**。由于可以交易无限次，因此所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。

```java
	public int maxProfit(int[] prices) {
        if(prices.length<=1) return 0;
        int max=0;
        for(int i=1;i<prices.length;i++){
            if(prices[i]>prices[i-1]){
                max+=prices[i]-prices[i-1];
            }
        }
        return max;
    }
```



## 子序列\子数组问题

### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

Difficulty: **中等**


给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：**

*   `1 <= nums.length <= 2500`
*   -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>

**进阶：**

*   你可以设计时间复杂度为 O(n<sup>2</sup>)的解决方案吗？
*   你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

**方法1：动态规划。dp[i]表示以i结尾的最长递增子序列。初始情况是dp数组全位1，状态转移方程是`dp[i] = max(1 + dp[j] if j < i and nums[j] < nums[i])`**。最大的dp[i]为最长递增子序列。

```java
	public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }

        int[] dp = new int[len];
        Arrays.fill(dp, 1);
		int res = 0;
        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
```

**方法2：贪心法+二分法。较难想到，很经典。**

思路：如果已经得到的上升子序列的**结尾的数越小**，那么遍历的时候后面接上一个数，**才会有更大的可能构成一个长度更长的上升子序列。**因此，我们可以记录在长度固定的情况下，结尾最小的那个元素的数值。

`tail[i]` 表示：长度为 `i + 1` 的 **所有** 上升子序列的结尾的最小值。

遍历过程中不断用当前值去更新tail数组。

- 如果当前数大于tail数组目前的最后一个元素，那么说明目前的最长上升子序列该增长了，直接把这个数放到最后面。
- 否则，用当前数去替换tail数组中第一个比它大的数。这样做的逻辑支撑是：假设tail数组中第一个比它大的数是tail[j]，tail[0]-tail[j-1]都比它小，说明找到了结尾更小的长度为j+1的上升子序列。tail[j+1]到tail[i]都比它大，插入当前元素并不影响长度大于j+1的上升子序列。
- 至于寻找tail数组(排序数组)中第一个比它大的位置，当然是用二分法。

```java
public int lengthOfLIS(int[] nums) {
    int len = nums.length;
    if (len <= 1) {
        return len;
    }

    int[] tail = new int[len];
    // 遍历第 1 个数，直接放在有序数组 tail 的开头
    tail[0] = nums[0];
    // end 表示有序数组 tail 的最后一个已经赋值元素的索引
    int end = 0;

    for (int i = 1; i < len; i++) {
        // 比 tail 数组实际有效的末尾的那个元素还大，直接添加在那个元素的后面，所以 end 先加 1
        if (nums[i] > tail[end]) {
            end++;
            tail[end] = nums[i];
        } else {
            // 使用二分查找法，在有序数组 tail 中
            // 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小
            int left = 0;
            int right = end;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (tail[mid] < nums[i]) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            tail[left] = nums[i];
        }
    }
    return end + 1;
}
```

