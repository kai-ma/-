**[167. 两数之和(二)——输入有序数组](#167-两数之和(二)——输入有序数组)** 通过这道题理解双指针的本质

[240. 搜索二维矩阵(二)](#240-搜索二维矩阵(二))

[11. 盛最多水的容器](#11-盛最多水的容器)



### [167. 两数之和(二)——输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

Difficulty: **简单**


给定一个已按照**升序排列 ** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。

函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值_。_`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**示例 2：**

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
```

**示例 3：**

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
```

**提示：**

*   2 <= numbers.length <= 3 * 10<sup>4</sup>
*   `-1000 <= numbers[i] <= 1000`
*   `numbers` 按 **递增顺序** 排列
*   `-1000 <= target <= 1000`
*   仅存在一个有效答案

**思路：[很好的题解](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/) 双指针，每移动一次直接排除一行或一列的遍历。复杂度降低N倍，从O(N^2)到O(N)**

<img src="https://pic.leetcode-cn.com/9ebb3ff74f0706c3c350b7fb91fea343e54750eb5b6ae6a4a3493421a019922a.gif" alt="搜索空间的减小过程（动图）" style="zoom:50%;" />

```java
public int[] twoSum(int[] numbers, int target) {
    int i = 0;
    int j = numbers.length - 1;
    while (i < j) {
        int sum = numbers[i] + numbers[j];
        if (sum < target) {
            i++;
        } else if (sum > target) {
            j--;
        } else {
            return new int[]{i+1, j+1};
        }
    }
    return new int[]{-1, -1};
}
```

**类似题：**

**[653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)。** 

只需要利用搜索二叉树的性质，中序遍历获取排序链表，然后用这道题的双指针方法即可。或者用HashSet，[1. 两数之和](#1-两数之和)这种方法。



### [240. 搜索二维矩阵(二)](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

Difficulty: **中等**


编写一个高效的算法来搜索 m x n 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

*   每行的元素从左到右升序排列。
*   每列的元素从上到下升序排列。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

**提示：**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= n, m <= 300`
*   -10<sup>9</sup> <= matix\[i][j] <= 10<sup>9</sup>
*   每行的所有元素从左到右升序排列
*   每列的所有元素从上到下升序排列
*   -10<sup>9</sup> <= target <= 10<sup>9</sup>

**思路：**与[167. 两数之和(二)——输入有序数组](#167-两数之和(二)——输入有序数组)相同，二维矩阵图都画出来了，从左下角或者右上角开始搜索。比如从左下角开始搜索，若target比当前值大，由于这一列是从小到大排序，target比这一行都大，所以直接排除这一列。如果target比当前值小，由于这一行是从小到大排序，target比这一行都小，直接排除这一行。

**也是移动一次就可以排除一行或一列，复杂度降低N倍，从O(N^2)到O(N)**

```java
	public boolean searchMatrix(int[][] matrix, int target) {
        // 从左下角开始搜索 也可以从右上角开始搜索
        int row = matrix.length - 1;
        int col = 0;
        while (row >= 0 && col < matrix[0].length) {
            if (matrix[row][col] > target) {
                row--;
            } else if (matrix[row][col] < target) {
                col++;
            } else { // found it
                return true;
            }
        }
        return false;
    }
```





### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

Difficulty: **中等**


给你 `n` 个非负整数 a<sub style="display: inline;">1</sub>，a<sub style="display: inline;">2，</sub>...，a<sub style="display: inline;">n，</sub>每个数代表坐标中的一个点 (i, a<sub style="display: inline;">i</sub>) 。在坐标内画 `n` 条垂直线，垂直线 `i` 的两个端点分别为 (i, a<sub style="display: inline;">i</sub>) 和 (i, 0) 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

**示例 1：**

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

**示例 3：**

```
输入：height = [4,3,2,1,4]
输出：16
```

**示例 4：**

```
输入：height = [1,2,1]
输出：2
```

**提示：**

*   `n = height.length`
*   2 <= n <= 3 * 10<sup>4</sup>
*   0 <= height[i] <= 3 * 10<sup>4</sup>

**思路：同[167. 两数之和(二)——输入有序数组](#167-两数之和(二)——输入有序数组)，左右双指针。**

- 所有的可能性是N^2/2
- 如果短指针不动，而把长指针向着另一端移动，两者的距离已经变小了，**无论会不会遇到更高的指针，结果都只是以短的指针来进行计算。** 故移动长指针是无意义的。因此考虑移动短指针
- 实际上，移动短指针排除的是以短指针为边界，长指针不断内移的这一行(列)，因为只有短的才起作用，所以排除这一行列不会对结果有影响，也是**移动一次就排除一行或一列，复杂度降低N倍，从O(N^2)到O(N)。**

```java
	public int maxArea(int[] height) {
        int i = 0, j = height.length - 1;
        int res = 0;
        while (i <= j) {
            res = Math.max(Math.min(height[j], height[i]) * (j - i), res);
            if (height[i] < height[j]) {
                i++;
            } else {
                j--;
            }
        }
        return res;
    }
```



