### 单次移动排除一行/列的遍历

​	**[167. 两数之和(二)——输入有序数组](#167-两数之和(二)——输入有序数组)** 通过这道题理解双指针的本质

​	[240. 搜索二维矩阵(二)](#240-搜索二维矩阵(二))

​	[11. 盛最多水的容器](#11-盛最多水的容器)



### 很直接的双指针

​	[88. 合并两个有序数组](#88-合并两个有序数组)



### 链表的双指针

​	[剑指 Offer 22. 链表中倒数第k个节点](#剑指-Offer-22-链表中倒数第k个节点)

​	**[141.环形链表](#141-环形链表)**

​	[142. 环形链表 II](#142-环形链表-II)



双指针主要用于遍历数组或链表，两个指针指向不同的元素，协同完成任务。具体而言，有左右双指针，快慢双指针，后序双指针等。



todo：[680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

[待总结](#Old)



## 单次移动排除一行/列的遍历

### [167. 两数之和(二)——输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

Difficulty: **简单**


给定一个已按照**升序排列 ** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。

函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值_。_`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**示例 2：**

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
```

**示例 3：**

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
```

**提示：**

*   2 <= numbers.length <= 3 * 10<sup>4</sup>
*   `-1000 <= numbers[i] <= 1000`
*   `numbers` 按 **递增顺序** 排列
*   `-1000 <= target <= 1000`
*   仅存在一个有效答案

**思路：[很好的题解](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/) 双指针，每移动一次直接排除一行或一列的遍历。复杂度降低N倍，从O(N^2)到O(N)**

<img src="https://pic.leetcode-cn.com/9ebb3ff74f0706c3c350b7fb91fea343e54750eb5b6ae6a4a3493421a019922a.gif" alt="搜索空间的减小过程（动图）" style="zoom:50%;" />

```java
public int[] twoSum(int[] numbers, int target) {
    int i = 0;
    int j = numbers.length - 1;
    while (i < j) {
        int sum = numbers[i] + numbers[j];
        if (sum < target) {
            i++;
        } else if (sum > target) {
            j--;
        } else {
            return new int[]{i+1, j+1};
        }
    }
    return new int[]{-1, -1};
}
```

**类似题：**

**[653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)。** 

只需要利用搜索二叉树的性质，中序遍历获取排序链表，然后用这道题的双指针方法即可。或者用HashSet，[1. 两数之和](#1-两数之和)这种方法。



### [240. 搜索二维矩阵(二)](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

Difficulty: **中等**


编写一个高效的算法来搜索 m x n 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

*   每行的元素从左到右升序排列。
*   每列的元素从上到下升序排列。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

**提示：**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= n, m <= 300`
*   -10<sup>9</sup> <= matix\[i][j] <= 10<sup>9</sup>
*   每行的所有元素从左到右升序排列
*   每列的所有元素从上到下升序排列
*   -10<sup>9</sup> <= target <= 10<sup>9</sup>

**思路：**与[167. 两数之和(二)——输入有序数组](#167-两数之和(二)——输入有序数组)相同，二维矩阵图都画出来了，从左下角或者右上角开始搜索。比如从左下角开始搜索，若target比当前值大，由于这一列是从小到大排序，target比这一行都大，所以直接排除这一列。如果target比当前值小，由于这一行是从小到大排序，target比这一行都小，直接排除这一行。

**也是移动一次就可以排除一行或一列，复杂度降低N倍，从O(N^2)到O(N)**

```java
	public boolean searchMatrix(int[][] matrix, int target) {
        // 从左下角开始搜索 也可以从右上角开始搜索
        int row = matrix.length - 1;
        int col = 0;
        while (row >= 0 && col < matrix[0].length) {
            if (matrix[row][col] > target) {
                row--;
            } else if (matrix[row][col] < target) {
                col++;
            } else { // found it
                return true;
            }
        }
        return false;
    }
```





### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

Difficulty: **中等**


给你 `n` 个非负整数 a<sub style="display: inline;">1</sub>，a<sub style="display: inline;">2，</sub>...，a<sub style="display: inline;">n，</sub>每个数代表坐标中的一个点 (i, a<sub style="display: inline;">i</sub>) 。在坐标内画 `n` 条垂直线，垂直线 `i` 的两个端点分别为 (i, a<sub style="display: inline;">i</sub>) 和 (i, 0) 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

**示例 1：**

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

**示例 3：**

```
输入：height = [4,3,2,1,4]
输出：16
```

**示例 4：**

```
输入：height = [1,2,1]
输出：2
```

**提示：**

*   `n = height.length`
*   2 <= n <= 3 * 10<sup>4</sup>
*   0 <= height[i] <= 3 * 10<sup>4</sup>

**思路：同[167. 两数之和(二)——输入有序数组](#167-两数之和(二)——输入有序数组)，左右双指针。**

- 所有的可能性是N^2/2
- 如果短指针不动，而把长指针向着另一端移动，两者的距离已经变小了，**无论会不会遇到更高的指针，结果都只是以短的指针来进行计算。** 故移动长指针是无意义的。因此考虑移动短指针
- 实际上，移动短指针排除的是以短指针为边界，长指针不断内移的这一行(列)，因为只有短的才起作用，所以排除这一行列不会对结果有影响，也是**移动一次就排除一行或一列，复杂度降低N倍，从O(N^2)到O(N)。**

```java
	public int maxArea(int[] height) {
        int i = 0, j = height.length - 1;
        int res = 0;
        while (i <= j) {
            res = Math.max(Math.min(height[j], height[i]) * (j - i), res);
            if (height[i] < height[j]) {
                i++;
            } else {
                j--;
            }
        }
        return res;
    }
```



### ⚡[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

Difficulty: **困难**


给定 _n_ 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

**提示：**

*   `n == height.length`
*   0 <= n <= 3 * 10<sup>4</sup>
*   0 <= height[i] <= 10<sup>5</sup>

```

```



## 很直接的双指针

[125. 验证回文串](./字符串.md/#125-验证回文串)



### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

Difficulty: **简单**


给你两个有序整数数组 `nums1`和 `nums2`，请你将 `nums2`合并到 `nums1`中_，_使 `nums1`成为一个有序数组。

初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n`。你可以假设 `nums1`的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```

**提示：**

*   `nums1.length == m + n`
*   `nums2.length == n`
*   `0 <= m, n <= 200`
*   `1 <= m + n <= 200`
*   -10<sup>9</sup> <= nums1[i], nums2[i] <= 10<sup>9</sup>

**思路：从后往前遍历 ，in place替换第一个数组**

```java
	public void merge(int[] nums1, int m, int[] nums2, int n) {
        if (n == 0) return;
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        //结束时必有i或者j等于-1  如果是j=-1，也就是nums1最前面还有更小的，保留不动就可以了
        //j>=0，nums2中还有更小的，需要移动到nums1
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
```









## 链表的双指针

### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

Difficulty: **简单**


输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 `6` 个节点，从头节点开始，它们的值依次是 `1、2、3、4、5、6`。这个链表的倒数第 `2` 个节点是值为 `4` 的节点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

```java
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode fast = head, slow = head;
        for (int i = 0; i < k; i++) {
            if (fast == null) {
                return null;
            }
            fast = fast.next;
        }
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
```



### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

Difficulty: **简单**


给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。

**进阶：**

你能用 _O(1)_（即，常量）内存解决此问题吗？

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**提示：**

*   链表中节点的数目范围是 [0, 10<sup>4</sup>]
*   -10<sup>5</sup> <= Node.val <= 10<sup>5</sup>
*   `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

思路：快慢指针，若存在环，必相遇。

```java
	public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {  //这个判断可以删掉
            return false;
        }
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                return true;
            }
        }
        return false;
    }
```



### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

Difficulty: **中等**


给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意，`pos` 仅仅是用于标识环的情况，并不会作为参数传递到函数中。**

**说明：**不允许修改给定的链表。

**进阶：**

*   你是否可以使用 `O(1)` 空间解决此题？

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

**提示：**

*   链表中节点的数目范围在范围 [0, 10<sup>4</sup>] 内
*   -10<sup>5</sup> <= Node.val <= 10<sup>5</sup>
*   `pos` 的值为 `-1` 或者链表中的一个有效索引

思路：判断是否存在，最直接的方法是Set，空间复杂度是O(N)。O(1)方法需要利用[141.环形链表](#141-环形链表)快慢双指针方法，这种方法需要数学证明，第一次做其实很难想到。

```java
	public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            if (fast == slow) {
                fast = head;
                while (fast != slow) {
                    fast = fast.next;
                    slow = slow.next;
                }
                return fast;
            }
        }
        return null;
    }
```



## Old

### 两数的平方和  -Ⅱ  

lc633. Sum of Square Numbers (Easy) [LeetCode](https://leetcode.com/problems/sum-of-square-numbers/)/[力扣](https://leetcode-cn.com/problems/sum-of-square-numbers/submissions/)  
给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。  

双指针right起始值选取：right=(int) Math.sqrt(num); left=0  
**(int)强制转换double类型，舍去小数位。**

```java
    public boolean judgeSquareSum(int c) {
        if(c<0) return false;
        int right=(int) Math.sqrt(c);
        int left=0;
        while(left<=right){
            long ret=left*left+right*right;
            if(ret==c){
                return true;
            }else if(ret>c){
                right--;
            }else
                left++;
        }
        return false;
    }
```

### 反转字符串中的元音字符  -Ⅰ

lc345. Reverse Vowels of a String (Easy) [LeetCode](https://leetcode.com/problems/reverse-vowels-of-a-string/)/[力扣](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)
判断元音字母的方法：
static final String vowels = "aeiouAEIOU"; vowels.indexOf(a) == -1  
或!vowels.contains(a)  

如果数据量比较大的话，用set。

```java
    private final String vowel="aeiouAEIOU";
    public String reverseVowels(String s) {
        int left=0, right=s.length()-1;
        char[] chars=s.toCharArray();
        while(left<right){
            while(left<right&&!isVowel(chars[left])) left++;
            while(left<right&&!isVowel(chars[right])) right--;
            swap(chars, left, right);
            left++; right--;
        }
        return new String(chars);
    }
    private boolean isVowel(char a){
        return vowel.indexOf(a)!=-1;
    }
    private void swap(char[] chars, int left, int right){
        char temp=chars[left];
        chars[left]=chars[right];
        chars[right]=temp;
    }
```

### 最多删除一个字符，判断是否为回文字符串 -Ⅱ

lc680. Valid Palindrome II (Easy) [LeetCode](https://leetcode.com/problems/valid-palindrome-ii/)/[力扣](https://leetcode-cn.com/problems/valid-palindrome-ii/)   

```
给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

示例 1:

输入: "aba"
输出: True
示例 2:

输入: "abca"
输出: True
解释: 你可以删除c字符。
注意:

字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。
```

思路：删除再判断 只需要判断中间的子字符串即可

```java
    public boolean validPalindrome(String s) {
        char[] chars = s.toCharArray();
        int i=0;
        int j=chars.length-1;

        while(i<j&&chars[i]==chars[j]){
            i++;
            j--;
        }
        return isValid(chars,i+1,j))||isValid(chars,i,j-1);
    }
    
    private boolean isValid(char[] chars,int i,int j){
        while(i<j){
            if(chars[i++]!=chars[j--]){
                return false;
            }
        }
        return true;
    }
```

