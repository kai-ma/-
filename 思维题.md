[31. 下一个排列](./思维题.md/#31-下一个排列)



### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

Difficulty: **中等**


实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须修改，只允许使用额外常数空间。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

**提示：**

*   `1 <= nums.length <= 100`
*   `0 <= nums[i] <= 100`

**思路：模拟找排列的过程，找出规律。**

从后往前第一个非递增的就是要换到后面去的，后面比它大的最小数就是要换到它这个位置上的。然后这个位置后面的所有数从小到大排列即可，也就是翻转一下。

验证一下特殊情况，当数组为递减数组的时候，下一个排列就是全反过来的递增数组，即第一个排列的状态。

```java
	public void nextPermutation(int[] nums) {
        int i = nums.length - 1;
        while (i > 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        i--;
        int j = nums.length - 1;
        if (i >= 0) {
            while (j > 0 && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    private void reverse(int[] nums, int left) {
        int right = nums.length - 1;
        while (left < right) {
            swap(nums, left++, right--);
        }
    }
```

