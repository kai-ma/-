[31. 下一个排列](./思维题.md/#31-下一个排列)

[738. 单调递增的数字](#738-单调递增的数字)







### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

Difficulty: **中等**


实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须修改，只允许使用额外常数空间。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

**提示：**

*   `1 <= nums.length <= 100`
*   `0 <= nums[i] <= 100`

**思路：模拟找排列的过程，找出规律。**

从后往前第一个非递增的就是要换到后面去的，后面比它大的最小数就是要换到它这个位置上的。然后这个位置后面的所有数从小到大排列即可，也就是翻转一下。

验证一下特殊情况，当数组为递减数组的时候，下一个排列就是全反过来的递增数组，即第一个排列的状态。

```java
	public void nextPermutation(int[] nums) {
        int i = nums.length - 1;
        while (i > 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        i--;
        int j = nums.length - 1;
        if (i >= 0) {
            while (j > 0 && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    private void reverse(int[] nums, int left) {
        int right = nums.length - 1;
        while (left < right) {
            swap(nums, left++, right--);
        }
    }
```



### [738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)

Difficulty: **中等**


给定一个非负整数 `N`，找出小于或等于 `N` 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。）

**示例 1:**

```
输入: N = 10
输出: 9
```

**示例 2:**

```
输入: N = 1234
输出: 1234
```

**示例 3:**

```
输入: N = 332
输出: 299
```

**说明:** `N` 是在 `[0, 10^9]` 范围内的一个整数。

**思路：贪心法，找到第一个错位的，把错位前面-1，然后后面全变成9。**

首先如果从高位到低位是递增的，那就是这个数本身，如示例2。只有出现了非递增，才需要修改。示例1中N=10，第一个非递增就是1比0大，1-1，0变成9，得到最大结果。再看示例3这种情况，第一个非递增是32，如果把3-1，2换成9，变成了329，还是非递增，因此应该把第一个3-1，这时候就能保证递增。因为3-1是2，32是第一个非递增的，因此3前面一定是递增序列，比如12332，1332这些情况，把第一个3-1，然后后面的所有值都变成9，就得到了结果。比如12332应该变成11999，1332应该变成1299，332应该变成299。

```java
public int monotoneIncreasingDigits(int N) {
    char[] arr = (N + "").toCharArray();
    int max = -1, idx = -1;
    for (int i = 0; i < arr.length - 1; i++) {
        if (max < arr[i]) {
            max = arr[i];
            idx = i;
        }
        if (arr[i] > arr[i + 1]) {
            arr[idx] -= 1;
            for (int j = idx + 1; j < arr.length; j++) {
                arr[j] = '9';
            }
            break;
        }
    }
    return Integer.parseInt(new String(arr));
}
```

