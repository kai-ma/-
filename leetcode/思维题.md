[31. 下一个排列](./思维题.md/#31-下一个排列)

[738. 单调递增的数字](#738-单调递增的数字)

[169. 多数元素](#169-多数元素) 摩尔投票法

[229. 求众数II](#229-求众数II)



### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

Difficulty: **中等**


实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须修改，只允许使用额外常数空间。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

**提示：**

*   `1 <= nums.length <= 100`
*   `0 <= nums[i] <= 100`

**思路：模拟找排列的过程，找出规律。**

从后往前第一个非递增的就是要换到后面去的，后面比它大的最小数就是要换到它这个位置上的。然后这个位置后面的所有数从小到大排列即可，也就是翻转一下。

验证一下特殊情况，当数组为递减数组的时候，下一个排列就是全反过来的递增数组，即第一个排列的状态。

```java
	public void nextPermutation(int[] nums) {
        int i = nums.length - 1;
        while (i > 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        i--;
        int j = nums.length - 1;
        if (i >= 0) {
            while (j > 0 && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    private void reverse(int[] nums, int left) {
        int right = nums.length - 1;
        while (left < right) {
            swap(nums, left++, right--);
        }
    }
```



### [738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)

Difficulty: **中等**


给定一个非负整数 `N`，找出小于或等于 `N` 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。

（当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。）

**示例 1:**

```
输入: N = 10
输出: 9
```

**示例 2:**

```
输入: N = 1234
输出: 1234
```

**示例 3:**

```
输入: N = 332
输出: 299
```

**说明:** `N` 是在 `[0, 10^9]` 范围内的一个整数。

**思路：贪心法，找到第一个错位的，把错位前面-1，然后后面全变成9。**

首先如果从高位到低位是递增的，那就是这个数本身，如示例2。只有出现了非递增，才需要修改。示例1中N=10，第一个非递增就是1比0大，1-1，0变成9，得到最大结果。再看示例3这种情况，第一个非递增是32，如果把3-1，2换成9，变成了329，还是非递增，因此应该把第一个3-1，这时候就能保证递增。因为3-1是2，32是第一个非递增的，因此3前面一定是递增序列，比如12332，1332这些情况，把第一个3-1，然后后面的所有值都变成9，就得到了结果。比如12332应该变成11999，1332应该变成1299，332应该变成299。

```java
public int monotoneIncreasingDigits(int N) {
    char[] arr = (N + "").toCharArray();
    int max = -1, idx = -1;
    for (int i = 0; i < arr.length - 1; i++) {
        if (max < arr[i]) {
            max = arr[i];
            idx = i;
        }
        if (arr[i] > arr[i + 1]) {
            arr[idx] -= 1;
            for (int j = idx + 1; j < arr.length; j++) {
                arr[j] = '9';
            }
            break;
        }
    }
    return Integer.parseInt(new String(arr));
}
```



### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

Difficulty: **简单**

**进阶题：[229. 求众数 II](#229-求众数II)**


给定一个大小为 _n_ 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

```
输入：[3,2,3]
输出：3
```

**示例 2：**

```
输入：[2,2,1,1,1,2,2]
输出：2
```

**进阶：**

*   尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

**思路：摩尔投票法。**因为超过半数，最终一定能把它投上去。

```java
public int majorityElement(int[] nums) {
    if (nums.length == 0) return -1;
    int res = nums[0];
    int count = 1;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] == res) {
            count++;
        } else {
            count--;
            if (count == 0) {
                res = nums[i];
                count = 1;
            }
        }
    }
    return res;
}
```

还可以使用位运算方法，这一位0超过半数，要找的数的这一位就是0，反之这一位就是1。

### [229. 求众数II](https://leetcode-cn.com/problems/majority-element-ii/)

Difficulty: **中等**


给定一个大小为 _n _的整数数组，找出其中所有出现超过 `⌊ n/3 ⌋` 次的元素。

**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。

**示例 1：**

```
输入：[3,2,3]
输出：[3]
```

**示例 2：**

```
输入：nums = [1]
输出：[1]
```

**示例 3：**

```
输入：[1,1,1,3,3,2,2,2]
输出：[1,2]
```

**提示：**

*   1 <= nums.length <= 5 * 10<sup>4</sup>
*   -10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>

**思路：摩尔投票法升级版。只需要做到：大于1/3，一定能被投出来。**最后得遍历检查是不是真的大于1/3。

我自己想出来的：第一遍用+2查询，找到候选人1。再遍历一遍用+1查询，并且跳过候选人1，找到候选人2。然后再检查这两个人是不是超过1/3。

```java
public List<Integer> majorityElement(int[] nums) {
    List<Integer> list = new ArrayList<>();
    if (nums.length == 0) {
        return list;
    }
    int candidate1 = nums[0];
    int count = 0;
    for (int num : nums) {
        if (count == 0) {
            candidate1 = num;
        }
        count += candidate1 == num ? 2 : -1;
    }
    count = 0;
    int candidate2 = nums[0];
    for (int num : nums) {
        if (num == candidate1) {
            continue;
        }
        if (count == 0) {
            candidate2 = num;
        }
        if (num == candidate2) {
            count += 1;
        } else {
            count--;
        }
    }
    int cnt1 = 0;
    int cnt2 = 0;
    for (int num : nums) {
        if (num == candidate1) {
            cnt1++;
        } else if (num == candidate2) {
            cnt2++;
        }
    }
    if (cnt1 > nums.length / 3) {
        list.add(candidate1);
    }
    if (cnt2 > nums.length / 3 && candidate2 != candidate1) {
        list.add(candidate2);
    }
    return list;
}
```

**答案区更简单的：+1，等于候选人1，就跳过候选人2。**

```java
public List<Integer> majorityElement(int[] nums) {
    List<Integer> res = new ArrayList<>();
    if (nums == null || nums.length == 0)
        return res;
    //初始化：定义两个候选人及其对应的票数
    int candidateA = nums[0];
    int candidateB = nums[0];
    int countA = 0;
    int countB = 0;
    //遍历数组
    for (int num : nums) {
        if (num == candidateA) {
            countA++;//投A
            continue;
        }
        if (num == candidateB) {
            countB++;//投B
            continue;
        }

        //此时当前值和AB都不等，检查是否有票数减为0的情况，如果为0，则更新候选人
        if (countA == 0) {
            candidateA = num;
            countA++;
            continue;
        }
        if (countB == 0) {
            candidateB = num;
            countB++;
            continue;
        }
        //若此时两个候选人的票数都不为0，且当前元素不投AB，那么A,B对应的票数都要--;
        countA--;
        countB--;
    }

    //上一轮遍历找出了两个候选人，但是这两个候选人是否均满足票数大于N/3仍然没法确定，需要重新遍历，确定票数
    countA = 0;
    countB = 0;
    for (int num : nums) {
        if (num == candidateA) {
            countA++;
        } else if (num == candidateB) {
            countB++;
        }
    }
    if (countA > nums.length / 3) {
        res.add(candidateA);
    }
    if (countB > nums.length / 3) {
        res.add(candidateB);
    }
    return res;
}

作者：pingpongbaoche
链接：https://leetcode-cn.com/problems/majority-element-ii/solution/duo-shu-tou-piao-de-sheng-ji-ban-hao-li-jie-java-b/
```

