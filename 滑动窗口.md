[3. 无重复字符的最长子串](#3-无重复字符的最长子串)

**[76. 最小覆盖子串](#76-最小覆盖子串)**

[209. 长度最小的子数组](#209-长度最小的子数组)



## TODO



### 滑动窗口做题思路

滑动窗口可以理解为双指针的一种特殊用法，一前一后两个指针，中间是窗口。

- 前指针不断向前移动，直到窗口中的字符满足条件。

- 移动后面的指针，直到不满足条件。每次移动，都要更新一轮结果。

再重复上述操作，直至遍历完整个数组。第 1 步相当于在寻找一个**「可行解」**，然后第 2 步在**优化这个「可行解」**，最终找到**最优解**

**模板：**

```java
	public String minWindow(String s, String t) {
        // 起始的时候，都位于 0，同方向移动
        int left = 0;
        int right = 0;
        while (right < sLen) {
            // 增大窗口
            window.add(s[right]);
            ...统计窗口数据等操作
            right++;
            //收缩窗口
            while (满足条件) {
                window.remove(s[left]);
                left++;
                ...更新可行解
            }
        }
        return 最优解;
    }
```

最典型题：[76. 最小覆盖子串](#76-最小覆盖子串)，反复理解。

[3. 无重复字符的最长子串](#3-无重复字符的最长子串)、[209. 长度最小的子数组](#209-长度最小的子数组)这两道题比较基础，思路一样。



### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

Difficulty: **中等**


给定一个字符串，请你找出其中不含有重复字符的 **最长子串 **的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**示例 4:**

```
输入: s = ""
输出: 0
```

**提示：**

*   0 <= s.length <= 5 * 10<sup>4</sup>
*   `s` 由英文字母、数字、符号和空格组成

**思路：滑动窗口。**left和right两个指针，[left, right]区间内没有重复的时候，right不断向右移动，在这个过程中不断更新result。如果遇到重复，left不断向前移动直到没有重复。

由于s由字母、数字、符号、空格组成，组成元素比较多，不太适合用数组，用Set或者Map比较好。

```java
	public int resgthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int right = 0, left = 0, res = 0;
        while (right < s.length()) {
            if (!set.contains(s.charAt(right))) {
                set.add(s.charAt(right));
                res = Math.max(res, set.size());
                right++;
            } else {
                set.remove(s.charAt(left++));
            }
        }
        return res;
    }
```

也可以用map记录当前char和当前位置，遇到重复的时候，直接读map中存的重复char的位置，相当于left直接跳到位。

```java
 	public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int res = 0;
        int left = 0, right = 0;
        while (right < s.length()) {
            if (map.containsKey(s.charAt(right))) {
                left = Math.max(left, map.get(s.charAt(right)) + 1);
            }
            map.put(s.charAt(right), right);
            res = Math.max(res, right - left + 1);
            right++;
        }
        return res;
    }
```

**相关高频题：**

[209. 长度最小的子数组](#209-长度最小的子数组)



### **[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)**

Difficulty: **困难**


给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
```

**提示：**

*   1 <= s.length, t.length <= 10<sup>5</sup>
*   `s` 和 `t` 由英文字母组成

**进阶：**你能设计一个在 `o(n)` 时间内解决此问题的算法吗？

**思路：滑动窗口。**显然是一个滑动窗口题，在模板基础上，需要收缩的条件是什么，这里用的valid变量。

```java
	public String minWindow(String s, String t) {
        int left = 0, right = 0;
        String res = "";
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        //right右移-扩大窗口时，每当window中当前字符的个数等于t中当前字符的个数，valid+1，
        //left左移-缩小窗口，寻找最优解时，每当window中当前字符的个数等于t中当前字符的个数，valid-1。
        int valid = 0;
        //先统计t中每个字符的个数
        for (char c : t.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        while (right < s.length()) {
            // 增大窗口
            char c = s.charAt(right);    
            right++;
            //...统计窗口数据等操作
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c))) {
                    valid++;
                }
            }
            //判断窗口是不是要收缩
            while (valid == need.size()) {
                char d = s.charAt(left);
                if (need.containsKey(d)) {
                    if (window.get(d).equals(need.get(d))) {
                        valid--;
                    }
                    window.put(d, window.get(d) - 1);
                }
                //更新可行解
                if (right - left + 1 < res.length() || res.length() == 0) {
                    res = s.substring(left, right); //注意前避后开
                }
                left++;
            }     
        }
        return res;
    }
```



### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

Difficulty: **中等**


给定一个含有 `n`个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和`≥ target`的长度最小的 **连续子数组** [nums<sub style="display: inline;">l</sub>, nums<sub style="display: inline;">l+1</sub>, ..., nums<sub style="display: inline;">r-1</sub>, nums<sub style="display: inline;">r</sub>] ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

*   1 <= target <= 10<sup>9</sup>
*   1 <= nums.length <= 10<sup>5</sup>
*   1 <= nums[i] <= 10<sup>5</sup>

**进阶：**

*   如果你已经实现`O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

**思路：滑动窗口。**比较简单，窗口的条件是子数组的和大于等于target，更新最优解即可。

```java
	public int minSubArrayLen(int s, int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int res = Integer.MAX_VALUE;
        int left = 0, right = 0;
        int sum = 0;
        while (right < nums.length) {
            sum += nums[right];
            while (sum >= s) {
                res = Math.min(res, right - left + 1);
                sum -= nums[left];
                left++;
            }
            right++;
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
```

**相关高频题：**

[3. 无重复字符的最长子串](#3-无重复字符的最长子串)