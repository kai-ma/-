### 排列组合

​	[46. 全排列](#46-全排列)

todo[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)



### 树的回溯法

**[257. 二叉树的所有路径](#257-二叉树的所有路径)**

​	[113. 路径总和(二)](#113-路径总和(二))

​	[⚡437. 路径总和(三)](#437-路径总和(三))



## 排列组合

### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

Difficulty: **中等**


给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

**思路：经典回溯法。**

```java
	public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> lists = new ArrayList<>();
        backtrack(lists, new ArrayList<Integer>(), new boolean[nums.length], nums);
        return lists;
    }

    private void backtrack(List<List<Integer>> lists, List<Integer> list, boolean[] visited, int[] nums){
        if(list.size() == nums.length){
            lists.add(new ArrayList(list));
            return;
        }
        for(int i = 0; i < nums.length; i++){
            if(!visited[i]){
                visited[i] = true;
                list.add(nums[i]);
                backtrack(lists, list, visited, nums);
                list.remove(list.size() - 1);
                visited[i] = false;
            }
        }
    }
```



## 树的回溯法

### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

Difficulty: **简单**


给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

**思路1：根左右，先序遍历沿路添加即可。** 

**思路2：其实这是一道典型的回溯法的题**

```java
    //1. 先序遍历
	public List<String> binaryTreePaths(TreeNode root) {
        List<String> list = new ArrayList<>();
        dfs(root, list, new StringBuilder());
        return list;
    }

    private void dfs(TreeNode root, List<String> list, StringBuilder path) {
        if (root == null) {
            return;
        }
        path.append(root.val);
        if (root.left == null && root.right == null) {
            list.add(path.toString());
        }
        dfs(root.left, list, new StringBuilder(path).append("->"));
        dfs(root.right, list, new StringBuilder(path).append("->"));
    }


	//2. 回溯法 共用一个StringBuilder，每层递归之后，在返回上一层之前，删除这一层添加的
	public List<String> binaryTreePaths(TreeNode root) {
        List<String> list = new ArrayList<>();
        backtrack(root, list, new StringBuilder());
        return list;
    }

    private void backtrack(TreeNode root, List<String> list, StringBuilder sb) {
        if (root == null) {
            return;
        }
        int preLength = sb.length();
        sb.append(root.val);
        if (root.left == null && root.right == null) {
            list.add(sb.toString());
        } else {
            sb.append("->");
            backtrack(root.left, list, sb);
            backtrack(root.right, list, sb);
        }
        sb.setLength(preLength); //回溯 删掉这一层加的
    }
```



### [113. 路径总和(二)](https://leetcode-cn.com/problems/path-sum-ii/)

Difficulty: **中等**   


给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。


**示例 1：**

![](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：[]
```

**示例 3：**

```
输入：root = [1,2], targetSum = 0
输出：[]
```

**提示：**

*   树中节点总数在范围 `[0, 5000]` 内
*   `-1000 <= Node.val <= 1000`
*   `-1000 <= targetSum <= 1000`

**思路：与[257. 二叉树的所有路径](#257-二叉树的所有路径)相同，回溯法。**

```java
 	public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> lists=new ArrayList<>();
        dfs(root,sum, lists, new ArrayList<Integer>());
        return lists;
    }
     private void dfs(TreeNode root, int sum, List<List<Integer>> res, ArrayList<Integer> tmp) {
        if (root == null) return;
        tmp.add(root.val);
        if (root.left == null && root.right == null && sum - root.val == 0) res.add(new ArrayList<>(tmp));
        dfs(root.left, sum - root.val, res, tmp);
        dfs(root.right, sum - root.val, res, tmp);
        tmp.remove(tmp.size() - 1);
    }
```



### [437. 路径总和(三)](https://leetcode-cn.com/problems/path-sum-iii/)

⚡Difficulty: **中等**


给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

**示例：**

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```

**思路一：双递归 O(N^2)**

**思路二：回溯 用一个list保持到当前的所有可能的路径和。**  平均情况下树的深度为logN，平均时间复杂度为O(NlogN)，最差情况O(N^2)

**思路三：回溯+hashmap  O(N)  比较难想到**。key为从root到当前的路径和，value为这种路径和的个数。以当前节点结束的路径和=root到当前路径和的个数 - root到沿路结点的路径和等于target的个数。

```java
    //方法一：双递归 给每一个结点做DFS O(N^2)
    public int pathSum(TreeNode root, int sum) {
        if (root == null) {
            return 0;
        }
        int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
        return ret;
    }

    private int pathSumStartWithRoot(TreeNode root, int sum) {
        if (root == null) {
            return 0;
        }
        int ret = 0;
        if (root.val == sum) {
            ret++;
        }
        ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
        return ret;
    }

    //方法二：list回溯
    class Solution {
        int cnt = 0;

        public int pathSum(TreeNode root, int sum) {
            if (root == null) {
                return cnt;
            }
            ArrayList<Integer> list = new ArrayList<>();
            // if(root!=null) list.add(root.val);
            backtrack(list, root, sum);
            return cnt;
        }

        private void backtrack(ArrayList<Integer> list, TreeNode root, int sum) {
            if (root == null) {
                return;
            }
            for (int i = 0; i < list.size(); i++) {
                list.set(i, list.get(i) + root.val);
                if (list.get(i) == sum) {
                    cnt++;
                }
            }
            list.add(root.val);
            if (root.val == sum) {
                cnt++;
            }
            backtrack(list, root.left, sum);
            backtrack(list, root.right, sum);
            //为了不影响其他路径 回溯 删除当前节点的，并把list中每个值都减回去。
            list.remove(list.size() - 1);
            for (int i = 0; i < list.size(); i++) {
                list.set(i, list.get(i) - root.val);
            }
        }
    }


    //方法三：HashMap回溯
    public int pathSum(TreeNode root, int sum) {
        HashMap<Integer, Integer> preSum = new HashMap();
        preSum.put(0, 1);
        return helper(root, 0, sum, preSum);
    }

    public int helper(TreeNode root, int currSum, int target, HashMap<Integer, Integer> preSum) {
        if (root == null) {
            return 0;
        }

        currSum += root.val;
        int res = preSum.getOrDefault(currSum - target, 0);
        preSum.put(currSum, preSum.getOrDefault(currSum, 0) + 1);

        res += helper(root.left, currSum, target, preSum) + helper(root.right, currSum, target, preSum);
        //为了不影响其他路径，回溯
        preSum.put(currSum, preSum.get(currSum) - 1);
        return res;
    }
```



## TODO

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)