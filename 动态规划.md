### 基础动态规划

​	**[70. 爬楼梯](#70-爬楼梯)**

​	**[121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)**

​	[122. 买卖股票的最佳时机(二)](#122-买卖股票的最佳时机(二))

​	

### 子问题为End类型

​	**[53. 最大子序和](#53-最大子序和)**

​	[152. 乘积最大子数组](#152-乘积最大子数组)



### 树的动态规划

​	**[96. 不同的二叉搜索树](#96-不同的二叉搜索树)**



### 回文串问题

​	**[5. 最长回文子串](#5-最长回文子串)**

​		[647. 回文子串](#647-回文子串)

​		[516. 最长回文子序列](#516-最长回文子序列)



Todo：

[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

[336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/)、

[214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)

todo：背包问题

[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)  动态规划



**动态规划的本质是不重复求解子问题，保存子问题的解，通过状态转移方程直接计算出当前问题，大大压缩时间复杂度。**



## 基础动态规划

### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

Difficulty: **简单**


假设你正在爬楼梯。需要 _n_ 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：给定 _n_ 是一个正整数。**

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

**思路：动态规划。实际上是斐波那契数列**

本问题其实常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于两部分部分之和：

- 爬上 n-1 阶楼梯的方法数量。因为再爬1阶就能到第n阶。

- 爬上 n-2 阶楼梯的方法数量，因为再爬2阶就能到第n阶。

所以我们得到公式 `dp[n] = dp[n-1] + dp[n-2]`

base case：`dp[1] = 1; dp[2] = 2;`

```java
    public int climbStairs(int n) {
        //n 为正整数，n = 1, 2的特殊情况也被处理了
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }

	//dp[i]只与dp[i - 1]和dp[i - 2]有关，可以进一步压缩空间复杂度
	public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int count1 = 1;
        int count2 = 2;
        for (int i = 3; i <= n; i++) {
            int temp = count2;
            count2 = temp + count1;
            count1 = temp;
        }
        return count2;
    }
```

### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**相同题：[剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)**

Difficulty: **简单**


给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

*   1 <= prices.length <= 10<sup>5</sup>
*   0 <= prices[i] <= 10<sup>4</sup>

**思路1：动态规划。**dp[i] 表示前i天的最大利润，则：`dp[i] = max(dp[i-1], prices[i]-minprice)`，minprice是从0到i-1的最小价格。

**思路2：贪心法。对于任意第i天，如果在这一天卖股票，在这一天的最大收益 `maxprofit =  price[i] - 从起始到i-1处的最小价格`。**每一天都计算这一天的maxprofit，并去更新最大收益，最终即可得到最大收益。

方法2其实是方法1的空间优化方法。

```java
	//方法1，动态规划。
	public int maxProfit(int[] prices) {
        int minprice = prices[0];
        int[] dp = new int[prices.length];
        for (int i = 1; i < prices.length; i++){
            minprice = Math.min(minprice, prices[i]);
            dp[i] = Math.max(dp[i - 1], prices[i] - minprice);
        }
        return dp[prices.length - 1];
    }

	//方法2：贪心法
	public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
```



### [122. 买卖股票的最佳时机(二)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

Difficulty: **简单**


给定一个数组，它的第 _i_ 个元素是一支给定股票第 _i_ 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

*   `1 <= prices.length <= 3 * 10 ^ 4`
*   `0 <= prices[i] <= 10 ^ 4`

**思路1：动态规划。**用两个数组，cash[i]表示当前持有现金时的最大收益，hold[i]表示当前持有股票时的最大收益。遍历数组不断更新即可。

![image.png](https://pic.leetcode-cn.com/041a4d01398359409ecc69dacc13a44d179dd1a2a9f43b1def80e9a6acceee55-image.png)

```java
	public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len <= 1) {
            return 0;
        }

        // cash：持有现金
        // stock：持有股票
        // 状态数组
        // 状态转移：cash → stock → cash → stock → cash → stock → cash
        int[] cash = new int[len];
        int[] stock = new int[len];

        cash[0] = 0;
        stock[0] = -prices[0];

        for (int i = 1; i < len; i++) {
            // 这两行调换顺序也是可以的
            cash[i] = Math.max(cash[i - 1], stock[i - 1] + prices[i]);
            stock[i] = Math.max(stock[i - 1], cash[i - 1] - prices[i]);
        }
        return cash[len - 1];
    }
```

**思路2：贪心法——在每一步总是做出在当前看来最好的选择，只要比前一天高，就卖**。由于可以交易无限次，因此所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。

```java
	public int maxProfit(int[] prices) {
        if(prices.length<=1) return 0;
        int max=0;
        for(int i=1;i<prices.length;i++){
            if(prices[i]>prices[i-1]){
                max+=prices[i]-prices[i-1];
            }
        }
        return max;
    }
```





## 子问题为End类型

子问题是以当前位置为结尾的....。

### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

Difficulty: **简单**


给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [0]
输出：0
```

**示例 4：**

```
输入：nums = [-1]
输出：-1
```

**示例 5：**

```
输入：nums = [-100000]
输出：-100000
```

**提示：**

*   1 <= nums.length <= 3 * 10<sup>4</sup>
*   -10<sup>5</sup> <= nums[i] <= 10<sup>5</sup>

**进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

**思路1：动态规划。**子问题是**以i位置为结尾的连续最大和**，把所有的dp[i]都计算出来，最大的就是该数组的连续子序列的最大和。状态转移方程： `dp[i] = Math.max(nums[i], nums[i] + dp[i - 1])`

**思路2：贪心法。**对于第i位置，考虑前面的以i-1为结尾的连续最大和，如果大于0，**对当前位置的有贡献**。如果小于零，从当前位置重新算。实际上相当于动态规划解法的空间优化到O(1)的解法。

```java
	//思路1：动态规划
	public int maxSubArray(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        // base case
        // 第一个元素前面没有子数组
        dp[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            // 状态转移方程
            dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }

	//思路2：贪心法
	public static int maxSubArray(int[] A) {
        int maxSoFar = A[0], maxEndingHere = A[0];
        for (int i = 1; i < A.length; ++i) {
            maxEndingHere = Math.max(maxEndingHere + A[i], A[i]);
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        return maxSoFar;
    }
```





### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

Difficulty: **中等**


给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

**示例 1:**

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

**方法1：动态规划**，imax记录包括当前数为结尾的连续子数组的最大值，`imax = max(imax * nums[i], nums[i])`， 由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin，`imin = min(imin * nums[i], nums[i])`，**当出现负数时交换imax与imin**，然后再进行计算。

```java
	public int maxProduct(int[] nums) {
        int res = nums[0];
        int imax = nums[0];   //记录包括当前数为结尾的连续子数组的最大值
        int imin = nums[0];	//记录包括当前数为结尾的连续子数组的最小值
        for(int i = 1; i < nums.length; i++){
            if(nums[i] < 0){  //乘以一个负数，会让大数变小，小数变大。因此进行交换
                int tmp = imax;
                imax = imin;
                imin = tmp;
            }
            imax = Math.max(nums[i], nums[i] * imax);
            imin = Math.min(nums[i], nums[i] * imin);
            res = Math.max(res, imax);
        }
        return res;
    }
```





## 树的动态规划

### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

Difficulty: **中等**


给定一个整数 _n_，求以 1 ... _n_ 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**思路：**这种1到n个的题目，往往有子问题的规律，要用动态规划来做。这篇题解的画图很清晰：https://leetcode-cn.com/problems/unique-binary-search-trees/solution/shou-hua-tu-jie-san-chong-xie-fa-dp-di-gui-ji-yi-h/

```java
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            for (int j = 0; j <= i - 1; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        
        return dp[n];
    }
```



## 回文串问题

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

Difficulty: **中等**


给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

**示例 3：**

```
输入：s = "a"
输出："a"
```

**示例 4：**

```
输入：s = "ac"
输出："a"
```

**提示：**

*   `1 <= s.length <= 1000`
*   `s` 仅由数字和英文字母（大写和/或小写）组成

**方法1：动态规划。**如果一个字符串已经是/不是回文串，在它的左右各加一个字符，直接就能判断出来这个新字符串是不是回文串。也就是说先判断出中间，再判断两边的话，可以利用到中间的判断，这是一种子问题，可以用动态规划去求解。

`dp[i][j]` 表示子串 `s[i..j]` 是否为回文子串

- 当`i = j`时，`dp[i][j]`是回文子串
- 当`j - i <= 2`时，`dp[i][j] = s[i] == s[j] `，即中间没有字母或中间有一个字母。
- 当`j - i > 2`时，`dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1] == true`

特别注意：`dp[i][j]`的值依赖于`dp[i + 1][j - 1]`的值，因此遍历顺序应该是先遍历i + 1，再遍历i；先遍历j，再遍历j + 1。用i--，j++即可。

**方法2：从中间开始向两边扩散。**对于每一个位置，都把它当作中心，然后向两边扩散。注意：如果只取这个位置然后扩散的话，只能找到长度为单数的回文串。对于长度为双数的也应该考虑到，选取相邻的两个数为中心，向两边扩散。时间复杂度同样也为O(N<sup>2</sup>)，空间复杂度O(1)，比动态规划方法还要好。

- 一种巧妙的方法是：想象给每个字符中都插入一个符号。例如babad，变成b#a#b#a#d，以字母为中心向两边拓展是单数长度字符串，以#为中心向两边拓展是双数长度字符串。

建议先掌握动态规划方法，还有一些相似的题，没办法用扩展法，只能用动态规划。

方法1：动态规划

```java
	public String longestPalindrome(String s) {
        int len = s.length();
        if (len <= 1) {
            return s;
        }
        boolean[][] dp = new boolean[len][len];
        int start = 0, end = 0;
        for (int i = len - 1; i >= 0; i--) {
            dp[i][i] = true;
            for (int j = i + 1; j < len; j++) {
                dp[i][j] = (j - i <= 2 || dp[i + 1][j - 1]) && s.charAt(i) == s.charAt(j);
                if (dp[i][j] && j - i + 1 > end - start) {
                    start = i;
                    end = j;
                }
            }
        }
        return s.substring(start, end + 1);
    }
```

方法2：从中心向两边扩展

```java
 	public String longestPalindrome(String s) {
        if (s.length() <= 1) {
            return s;
        }
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expand(s, i, i);
            int len2 = expand(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    private int expand(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
```

假象有#：

```java
	public String longestPalindrome(String s) {
        int len = s.length();
        String res = "";
        for (int center = 0; center < len * 2 - 1; center++) {
            int left = center / 2;
            int right = left + center % 2;
            while (left >= 0 && right < len && s.charAt(left) == s.charAt(right)) {
                String tmp = s.substring(left, right + 1);
                if (tmp.length() > res.length()) {
                    res = tmp;
                }
                left--;
                right++;
            }
        }
        return res;
    }
```

这个问题还有一个巧妙的解法：Manacher's Algorithm（马拉车算法），时间复杂度只需要 O(N)，不过该解法比较复杂，我个人认为很少有人能第一次遇到这道题就能想出来这种方法，面试时候不会问到这么变态的，没必要掌握。有兴趣的同学可以自行搜索一下。

**相关高频题：**

[516. 最长回文子序列](#516-最长回文子序列)



### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

Difficulty: **中等**


给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 1：**

```
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

**提示：**

*   输入的字符串长度不会超过 1000 。

**思路：与[5. 最长回文子串](#5-最长回文子串)完全相同。**把更新大小换成增加数量即可。



### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

Difficulty: **中等**


给定一个字符串 `s` ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 `s` 的最大长度为 `1000` 。

**示例 1:**  
输入:

```
"bbbab"
```

输出:

```
4
```

一个可能的最长回文子序列为 "bbbb"。

**示例 2:**  
输入:

```
"cbbd"
```

输出:

```
2
```

一个可能的最长回文子序列为 "bb"。

**提示：**

*   `1 <= s.length <= 1000`
*   `s` 只包含小写英文字母

**思路：**与[5. 最长回文子串](#5-最长回文子串)相似，`dp[i][j]`表示从i到j前闭后闭子字符串内的最长回文子序列。

- 当`i = j`时，`dp[i][j] = 1`; 当i = j - 1时，如果`s.charAt(i) = s.charAt(j)`，`dp[i][j] = 2`，否则`dp[i][j] = 0`。
- 如果`s.charAt(i) = s.charAt(j)`， `dp[i][j] = dp[i + 1][j - 1] + 2`
- 否则，`dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])`

```java
	public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int[][] dp = new int[len][len];
        for (int i = len - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < len; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][len - 1];
    }
```

