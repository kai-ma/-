### 基础动态规划

​	**[70. 爬楼梯](#70-爬楼梯)**

​			[198. 打家劫舍](#198-打家劫舍)

​	**[121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)**

​	[122. 买卖股票的最佳时机(二)](#122-买卖股票的最佳时机(二))

⚡**[42. 接雨水](#42-接雨水)**

​			[238. 除自身以外数组的乘积](#238-除自身以外数组的乘积)

### 子序列\子数组问题

​	**[53. 最大子序和](#53-最大子序和)**

​	[152. 乘积最大子数组](#152-乘积最大子数组)

​	**[300. 最长递增子序列](#300-最长递增子序列)**



### 树的动态规划

​	**[96. 不同的二叉搜索树](#96-不同的二叉搜索树)**



### 回文串问题

​	**[5. 最长回文子串](#5-最长回文子串)**

​		[647. 回文子串](#647-回文子串)

​		[516. 最长回文子序列](#516-最长回文子序列)

Todo：

[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

[336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/)、

[214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)



### 背包问题

​	[322. 零钱兑换](#322-零钱兑换)

​		[279. 完全平方数](#279-完全平方数)

​		[983. 最低票价](#983-最低票价)

todo[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/) 



步骤：

- 定义子问题
- 写出子问题的递推关系
- 确定 DP 数组的计算顺序
- 空间优化（可选）

**动态规划的本质是不重复求解子问题，保存子问题的解，通过状态转移方程直接计算出当前问题，大大压缩时间复杂度。**

如果直接用递归，很多情况下由于重复计算，会超时。带记忆的递归相当于动态规划。



## 基础动态规划

### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

Difficulty: **简单**


假设你正在爬楼梯。需要 _n_ 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：给定 _n_ 是一个正整数。**

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

**思路：动态规划。实际上是斐波那契数列**

本问题其实常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于两部分部分之和：

- 爬上 n-1 阶楼梯的方法数量。因为再爬1阶就能到第n阶。

- 爬上 n-2 阶楼梯的方法数量，因为再爬2阶就能到第n阶。

所以我们得到公式 `dp[n] = dp[n-1] + dp[n-2]`

base case：`dp[1] = 1; dp[2] = 2;`

```java
    public int climbStairs(int n) {
        //n 为正整数，n = 1, 2的特殊情况也被处理了
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }

	//dp[i]只与dp[i - 1]和dp[i - 2]有关，可以进一步压缩空间复杂度
	public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int count1 = 1;
        int count2 = 2;
        for (int i = 3; i <= n; i++) {
            int temp = count2;
            count2 = temp + count1;
            count1 = temp;
        }
        return count2;
    }
```



### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

Difficulty: **中等**


你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**

*   `0 <= nums.length <= 100`
*   `0 <= nums[i] <= 400`

思路：类似于跳台阶问题。

dp[i]表示前 i 间房屋能偷窃到的最高总金额，状态转移方程：`Math.max(dp[i-1], dp[i-2] + nums[i-1])`。

```java
    public int rob(int[] nums) {
        int len = nums.length;
        if(len == 0)
            return 0;
        int[] dp = new int[len + 1];
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i = 2; i <= len; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
        }
        return dp[len];
    }
```



### [213\. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

Difficulty: **中等**


你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，能够偷窃到的最高金额。

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3：**

```
输入：nums = [0]
输出：0
```

**提示：**

*   `1 <= nums.length <= 100`
*   `0 <= nums[i] <= 1000`

**思路：**

数组是个环，也就是说偷第一家，最后一家就不能偷；偷最后一家，第一家就不能偷。

所以，我们问题分成求 nums[0:n - 1]或者 nums[1:n]，就变成了[198. 打家劫舍](#198-打家劫舍)。





### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**相同题：[剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)**

Difficulty: **简单**


给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

*   1 <= prices.length <= 10<sup>5</sup>
*   0 <= prices[i] <= 10<sup>4</sup>

**思路1：动态规划。**dp[i] 表示前i天的最大利润，则：`dp[i] = max(dp[i-1], prices[i]-minprice)`，minprice是从0到i-1的最小价格。

**思路2：贪心法。对于任意第i天，如果在这一天卖股票，在这一天的最大收益 `maxprofit =  price[i] - 从起始到i-1处的最小价格`。**每一天都计算这一天的maxprofit，并去更新最大收益，最终即可得到最大收益。

方法2其实是方法1的空间优化方法。

```java
	//方法1，动态规划。
	public int maxProfit(int[] prices) {
        int minprice = prices[0];
        int[] dp = new int[prices.length];
        for (int i = 1; i < prices.length; i++){
            minprice = Math.min(minprice, prices[i]);
            dp[i] = Math.max(dp[i - 1], prices[i] - minprice);
        }
        return dp[prices.length - 1];
    }

	//方法2：贪心法
	public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
```



### [122. 买卖股票的最佳时机(二)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

Difficulty: **简单**


给定一个数组，它的第 _i_ 个元素是一支给定股票第 _i_ 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

*   `1 <= prices.length <= 3 * 10 ^ 4`
*   `0 <= prices[i] <= 10 ^ 4`

**思路1：动态规划。**用两个数组，cash[i]表示当前持有现金时的最大收益，hold[i]表示当前持有股票时的最大收益。遍历数组不断更新即可。

![image.png](https://pic.leetcode-cn.com/041a4d01398359409ecc69dacc13a44d179dd1a2a9f43b1def80e9a6acceee55-image.png)

```java
	public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len <= 1) {
            return 0;
        }

        // cash：持有现金
        // stock：持有股票
        // 状态数组
        // 状态转移：cash → stock → cash → stock → cash → stock → cash
        int[] cash = new int[len];
        int[] stock = new int[len];

        cash[0] = 0;
        stock[0] = -prices[0];

        for (int i = 1; i < len; i++) {
            // 这两行调换顺序也是可以的
            cash[i] = Math.max(cash[i - 1], stock[i - 1] + prices[i]);
            stock[i] = Math.max(stock[i - 1], cash[i - 1] - prices[i]);
        }
        return cash[len - 1];
    }
```

**思路2：贪心法——在每一步总是做出在当前看来最好的选择，只要比前一天高，就卖**。由于可以交易无限次，因此所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。

```java
	public int maxProfit(int[] prices) {
        if(prices.length<=1) return 0;
        int max=0;
        for(int i=1;i<prices.length;i++){
            if(prices[i]>prices[i-1]){
                max+=prices[i]-prices[i-1];
            }
        }
        return max;
    }
```



### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

Difficulty: **困难**

**相关题：**[238. 除自身以外数组的乘积](#238-除自身以外数组的乘积)


给定 _n_ 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![](images/动态规划/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

**提示：**

*   `n == height.length`
*   0 <= n <= 3 * 10<sup>4</sup>
*   0 <= height[i] <= 10<sup>5</sup>

进阶：[407. 接雨水 II](https://leetcode-cn.com/problems/trapping-rain-water-ii/) 面试一般不会这么难

**方法1：动态规划。left[i]表示i左侧的最大值，即区间[0,i)的最大值，right[i]表示i右侧的最大值，即区间(i,len-1]的最大值。如果i位置比左右两侧的最大值要小，说明i位置可以存水。水量取决于短板**

```java
	public int trap(int[] height) {
        int res = 0;
        int[] left = new int[height.length];
        int[] right = new int[height.length];

        for (int i = 1; i < height.length - 1; i++) {
            left[i] = Math.max(left[i - 1], height[i - 1]);
        }
        for (int i = height.length - 2; i >= 0; i--) {
            right[i] = Math.max(right[i + 1], height[i + 1]);
        }
        for (int i = 1; i < height.length - 1; i++) {
            int min = Math.min(left[i], right[i]);
            if (height[i] < min) {
                res = res + (min - height[i]);
            }
        }
        return res;
    }
```

**方法2：单调递减栈。**如果是单调递减数组，不能蓄水，因此需要把单调递减的先存起来，遇到后面大的数再看能不能在栈顶这个小的数的位置上蓄水。

```java
	public int trap(int[] height) {
        int res = 0;
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < height.length; i++) {
            //如果栈不空并且当前指向的高度大于栈顶高度就一直循环
            while (!stack.empty() && height[i] > height[stack.peek()]) {
                //取出要出栈的元素
                int h = height[stack.pop()];
                // 栈空，原栈顶元素和当前元素之间没有空隙了，不会再有雨水。
                if (!stack.empty()) {
                    //两堵墙之前的距离。
                    int distance = i - stack.peek() - 1;
                    int min = Math.min(height[stack.peek()], height[i]);
                    res = res + distance * (min - h);
                }
            }
            //当前指向的墙入栈
            stack.push(i);
        }
        return res;
    }
```

**方法3：双指针。**假设一开始`left-1`大于`right+1`，则之后`right`一直向左移动，直到`right+1`大于`left-1`。在这段时间内`right`所遍历的所有点都是左侧最高点`maxleft`大于右侧最高点`maxright`的，所以只需要判断`maxright`与当前高度的关系就能知道i处能不能蓄水。反之`left`右移，所经过的点只要判断`maxleft`与当前高度的关系就行。

```java
	public int trap(int[] height) {
        int leftMax = 0, rightMax = 0;
        int left = 0, right = height.length - 1;
        int res = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] < leftMax) {
                    //当前值比leftMax小，并且一定比rightMax小，此处可以蓄水。
                    res += leftMax - height[left];
                } else {
                    //当前值比leftMax大，此处不能蓄水，更新leftMax。
                    leftMax = height[left];
                }
                left++;
            } else {
                if (height[right] < rightMax) {
                    res += rightMax - height[right];
                } else {
                    rightMax = height[right];
                }
                right--;
            }
        }
        return res;
    }
```

**直接用leftMax和rightMax比较会更容易理解：**

对于位置`left`而言，它左边最大值一定是left_max，右边最大值“大于等于”right_max，这时候，如果`left_max<right_max`成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。 所以当`left_max<right_max`时，我们就希望去处理left下标，反之，我们希望去处理right下标。

注意while循环结束条件是left<=right。

```java
	public int trap(int[] height) {
        int leftMax = 0, rightMax = 0;
        int left = 0, right = height.length - 1;
        int res = 0;
        while (left <= right) {
            if(leftMax < rightMax){
                res += Math.max(0, leftMax - height[left]);
                leftMax = Math.max(leftMax, height[left]);
                left++;
            }else{
                res += Math.max(0, rightMax - height[right]);
                rightMax = Math.max(rightMax, height[right]);
                right--;
            }
        }
        return res;
    }
```

方法4：韦恩图。很难想出来。[题解](https://leetcode-cn.com/problems/trapping-rain-water/solution/wei-en-tu-jie-fa-zui-jian-dan-yi-dong-10xing-jie-j/)

<img src="images/栈/53ab7a66023039ed4dce42b709b4997d2ba0089077912d39a0b31d3572a55d0b-trapping_rain_water.png" alt="trapping_rain_water.png" style="zoom:50%;" />

图1从左往右`S1+=max1且max1逐步增大`。图2从右往左`S2+=max2且max2逐步增大`。S1 + S2会覆盖整个矩形，并且：重复面积 = 柱子面积 + 积水面积。最终， 积水面积 = S1 + S2 - 矩形面积 - 柱子面积



### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

Difficulty: **中等**


给你一个长度为 _n_ 的整数数组 `nums`，其中 _n_ > 1，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

**示例:**

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

**提示：**题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

**说明:** 请**不要使用除法，**且在 O(_n_) 时间复杂度内完成此题。

**进阶：**  
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

**思路：如果能完全理解[42. 接雨水](#42-接雨水)，那么这道题就应该能耐迎刃而解。**

**初步方法：**left[i] 和 right[i] 分别表示i左右两侧，不包括nums[i]的乘积列表。**状态转移方程：res[i] = left[i] * right[i];**

```java
	public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        // left[i] 和 right[i] 分别表示i左右两侧，不包括nums[i]的乘积列表。res[i] = left[i] * right[i];
        int[] left = new int[length], right = new int[length], res = new int[length];
        left[0] = 1;
        for (int i = 1; i < length; i++) {
            left[i] = nums[i - 1] * left[i - 1];
        }
        right[length - 1] = 1;
        for (int i = length - 2; i >= 0; i--) {
            right[i] = nums[i + 1] * right[i + 1];
        }
        for (int i = 0; i < length; i++) {
            res[i] = left[i] * right[i];
        }
        return res;
    }
```

**优化方法：压缩空间到常数空间。**题目已经提示了： 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。即可以把输出数组作为left，然后再想办法省去right数组即可。对于当前right[i]，只有right[i+1]影响结果，因此right数组可以用变量替代。

```java
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] res = new int[length];

        res[0] = 1;
        //把res数组当成left数组
        for (int i = 1; i < length; i++) {
            res[i] = nums[i - 1] * res[i - 1];
        }

        //用right变量替代right数组
        int right = 1;
        for (int i = length - 1; i >= 0; i--) {
            res[i] = res[i] * right;
            right *= nums[i];
        }
        return res;
    }
```





## 子序列、子数组问题

一般子问题是以当前位置为结尾的....。

### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

Difficulty: **简单**


给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [0]
输出：0
```

**示例 4：**

```
输入：nums = [-1]
输出：-1
```

**示例 5：**

```
输入：nums = [-100000]
输出：-100000
```

**提示：**

*   1 <= nums.length <= 3 * 10<sup>4</sup>
*   -10<sup>5</sup> <= nums[i] <= 10<sup>5</sup>

**进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

**思路1：动态规划。**子问题是**以i位置为结尾的连续最大和**，把所有的dp[i]都计算出来，最大的就是该数组的连续子序列的最大和。状态转移方程： `dp[i] = Math.max(nums[i], nums[i] + dp[i - 1])`

**思路2：贪心法。**对于第i位置，考虑前面的以i-1为结尾的连续最大和，如果大于0，**对当前位置的有贡献**。如果小于零，从当前位置重新算。实际上相当于动态规划解法的空间优化到O(1)的解法。

```java
	//思路1：动态规划
	public int maxSubArray(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        // base case
        // 第一个元素前面没有子数组
        dp[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            // 状态转移方程
            dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }

	//思路2：贪心法
	public static int maxSubArray(int[] A) {
        int maxSoFar = A[0], maxEndingHere = A[0];
        for (int i = 1; i < A.length; ++i) {
            maxEndingHere = Math.max(maxEndingHere + A[i], A[i]);
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        return maxSoFar;
    }
```





### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

Difficulty: **中等**


给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

**示例 1:**

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

**方法1：动态规划**，imax记录包括当前数为结尾的连续子数组的最大值，`imax = max(imax * nums[i], nums[i])`， 由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin，`imin = min(imin * nums[i], nums[i])`，**当出现负数时交换imax与imin**，然后再进行计算。

```java
	public int maxProduct(int[] nums) {
        int res = nums[0];
        int imax = nums[0];   //记录包括当前数为结尾的连续子数组的最大值
        int imin = nums[0];	//记录包括当前数为结尾的连续子数组的最小值
        for(int i = 1; i < nums.length; i++){
            if(nums[i] < 0){  //乘以一个负数，会让大数变小，小数变大。因此进行交换
                int tmp = imax;
                imax = imin;
                imin = tmp;
            }
            imax = Math.max(nums[i], nums[i] * imax);
            imin = Math.min(nums[i], nums[i] * imin);
            res = Math.max(res, imax);
        }
        return res;
    }
```



### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

Difficulty: **中等**


给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：**

*   `1 <= nums.length <= 2500`
*   -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>

**进阶：**

*   你可以设计时间复杂度为 O(n<sup>2</sup>)的解决方案吗？
*   你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

**方法1：动态规划。dp[i]表示以i结尾的最长递增子序列。初始情况是dp数组全位1，状态转移方程是`dp[i] = max(1 + dp[j] if j < i and nums[j] < nums[i])`**。最大的dp[i]为最长递增子序列。

```java
	public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }

        int[] dp = new int[len];
        Arrays.fill(dp, 1);
		int res = 0;
        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
```

**方法2：贪心法+二分法。较难想到，很经典。**

思路：如果已经得到的上升子序列的**结尾的数越小**，那么遍历的时候后面接上一个数，**才会有更大的可能构成一个长度更长的上升子序列。**因此，我们可以记录在长度固定的情况下，结尾最小的那个元素的数值。

`tail[i]` 表示：长度为 `i + 1` 的 **所有** 上升子序列的结尾的最小值。

遍历过程中不断用当前值去更新tail数组。

- 如果当前数大于tail数组目前的最后一个元素，那么说明目前的最长上升子序列该增长了，直接把这个数放到最后面。
- 否则，用当前数去替换tail数组中第一个比它大的数。这样做的逻辑支撑是：假设tail数组中第一个比它大的数是tail[j]，tail[0]-tail[j-1]都比它小，说明找到了结尾更小的长度为j+1的上升子序列。tail[j+1]到tail[i]都比它大，插入当前元素并不影响长度大于j+1的上升子序列。
- 至于寻找tail数组(排序数组)中第一个比它大的位置，当然是用二分法。

```java
public int lengthOfLIS(int[] nums) {
    int len = nums.length;
    if (len <= 1) {
        return len;
    }

    int[] tail = new int[len];
    // 遍历第 1 个数，直接放在有序数组 tail 的开头
    tail[0] = nums[0];
    // end 表示有序数组 tail 的最后一个已经赋值元素的索引
    int end = 0;

    for (int i = 1; i < len; i++) {
        // 比 tail 数组实际有效的末尾的那个元素还大，直接添加在那个元素的后面，所以 end 先加 1
        if (nums[i] > tail[end]) {
            end++;
            tail[end] = nums[i];
        } else {
            // 使用二分查找法，在有序数组 tail 中
            // 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小
            int left = 0;
            int right = end;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (tail[mid] < nums[i]) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            tail[left] = nums[i];
        }
    }
    return end + 1;
}
```



## 树的动态规划

### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

Difficulty: **中等**


给定一个整数 _n_，求以 1 ... _n_ 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**思路：**这种1到n个的题目，往往有子问题的规律，要用动态规划来做。这篇题解的画图很清晰：https://leetcode-cn.com/problems/unique-binary-search-trees/solution/shou-hua-tu-jie-san-chong-xie-fa-dp-di-gui-ji-yi-h/

```java
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            for (int j = 0; j <= i - 1; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        
        return dp[n];
    }
```



## 回文串问题

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

Difficulty: **中等**


给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

**示例 3：**

```
输入：s = "a"
输出："a"
```

**示例 4：**

```
输入：s = "ac"
输出："a"
```

**提示：**

*   `1 <= s.length <= 1000`
*   `s` 仅由数字和英文字母（大写和/或小写）组成

**方法1：动态规划。**如果一个字符串已经是/不是回文串，在它的左右各加一个字符，直接就能判断出来这个新字符串是不是回文串。也就是说先判断出中间，再判断两边的话，可以利用到中间的判断，这是一种子问题，可以用动态规划去求解。

`dp[i][j]` 表示子串 `s[i..j]` 是否为回文子串

- 当`i = j`时，`dp[i][j]`是回文子串
- 当`j - i <= 2`时，`dp[i][j] = s[i] == s[j] `，即中间没有字母或中间有一个字母。
- 当`j - i > 2`时，`dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1] == true`

特别注意：`dp[i][j]`的值依赖于`dp[i + 1][j - 1]`的值，因此遍历顺序应该是先遍历i + 1，再遍历i；先遍历j，再遍历j + 1。用i--，j++即可。

**方法2：从中间开始向两边扩散。**对于每一个位置，都把它当作中心，然后向两边扩散。注意：如果只取这个位置然后扩散的话，只能找到长度为单数的回文串。对于长度为双数的也应该考虑到，选取相邻的两个数为中心，向两边扩散。时间复杂度同样也为O(N<sup>2</sup>)，空间复杂度O(1)，比动态规划方法还要好。

- 一种巧妙的方法是：想象给每个字符中都插入一个符号。例如babad，变成b#a#b#a#d，以字母为中心向两边拓展是单数长度字符串，以#为中心向两边拓展是双数长度字符串。

建议先掌握动态规划方法，还有一些相似的题，没办法用扩展法，只能用动态规划。

方法1：动态规划

```java
	public String longestPalindrome(String s) {
        int len = s.length();
        if (len <= 1) {
            return s;
        }
        boolean[][] dp = new boolean[len][len];
        int start = 0, end = 0;
        for (int i = len - 1; i >= 0; i--) {
            dp[i][i] = true;
            for (int j = i + 1; j < len; j++) {
                dp[i][j] = (j - i <= 2 || dp[i + 1][j - 1]) && s.charAt(i) == s.charAt(j);
                if (dp[i][j] && j - i + 1 > end - start) {
                    start = i;
                    end = j;
                }
            }
        }
        return s.substring(start, end + 1);
    }
```

方法2：从中心向两边扩展

```java
 	public String longestPalindrome(String s) {
        if (s.length() <= 1) {
            return s;
        }
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expand(s, i, i);
            int len2 = expand(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    private int expand(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
```

假象有#：

```java
	public String longestPalindrome(String s) {
        int len = s.length();
        String res = "";
        for (int center = 0; center < len * 2 - 1; center++) {
            int left = center / 2;
            int right = left + center % 2;
            while (left >= 0 && right < len && s.charAt(left) == s.charAt(right)) {
                String tmp = s.substring(left, right + 1);
                if (tmp.length() > res.length()) {
                    res = tmp;
                }
                left--;
                right++;
            }
        }
        return res;
    }
```

这个问题还有一个巧妙的解法：Manacher's Algorithm（马拉车算法），时间复杂度只需要 O(N)，不过该解法比较复杂，我个人认为很少有人能第一次遇到这道题就能想出来这种方法，面试时候不会问到这么变态的，没必要掌握。有兴趣的同学可以自行搜索一下。

**相关高频题：**

[516. 最长回文子序列](#516-最长回文子序列)



### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

Difficulty: **中等**


给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 1：**

```
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

**提示：**

*   输入的字符串长度不会超过 1000 。

**思路：与[5. 最长回文子串](#5-最长回文子串)完全相同。**把更新大小换成增加数量即可。



### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

Difficulty: **中等**


给定一个字符串 `s` ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 `s` 的最大长度为 `1000` 。

**示例 1:**  
输入:

```
"bbbab"
```

输出:

```
4
```

一个可能的最长回文子序列为 "bbbb"。

**示例 2:**  
输入:

```
"cbbd"
```

输出:

```
2
```

一个可能的最长回文子序列为 "bb"。

**提示：**

*   `1 <= s.length <= 1000`
*   `s` 只包含小写英文字母

**思路：**与[5. 最长回文子串](#5-最长回文子串)相似，`dp[i][j]`表示从i到j前闭后闭子字符串内的最长回文子序列。

- 当`i = j`时，`dp[i][j] = 1`; 当i = j - 1时，如果`s.charAt(i) = s.charAt(j)`，`dp[i][j] = 2`，否则`dp[i][j] = 0`。
- 如果`s.charAt(i) = s.charAt(j)`， `dp[i][j] = dp[i + 1][j - 1] + 2`
- 否则，`dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])`

```java
	public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int[][] dp = new int[len][len];
        for (int i = len - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < len; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][len - 1];
    }
```



## 背包问题

**核心：dp[i]表示以当前位置为结尾的最...。尝试用前面的可行解填充当前的。**

其实这类题用回溯法也同样能解，但是如果剪枝不够完全，就会超时。回溯是递归的一种，又回到了那个问题，动态规划是带记忆化的回溯。



### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

Difficulty: **中等**


给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**示例 4：**

```
输入：coins = [1], amount = 1
输出：1
```

**示例 5：**

```
输入：coins = [1], amount = 2
输出：2
```

**提示：**

*   `1 <= coins.length <= 12`
*   1 <= coins[i] <= 2<sup>31</sup> - 1
*   0 <= amount <= 10<sup>4</sup>

**思路：类似于完全背包问题。cost数组填充dp数组**

**dp[i]表示组成i的最少硬币个数，dp[i] = 1 + Math.min(dp[i-amout[0]], dp[i-amout[1]]....dp[i-amount[amount.length-1]])，前提是i<=amount并且dp[i-amout]有效。**

```java
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;

        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
        
        return dp[amount] == amount + 1 ? -1 : dp[amount];
    }
```

**相关题：**

[279. 完全平方数](#279-完全平方数)

[983. 最低票价](#983-最低票价)



### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

Difficulty: **中等**


给定正整数 _n_，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 _n_。你需要让组成和的完全平方数的个数最少。

给你一个整数 `n` ，返回和为 `n` 的完全平方数的 **最少数量** 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

**提示：**

*   1 <= n <= 10<sup>4</sup

**思路：类似[322. 零钱兑换](#322-零钱兑换)，用背包填充，尝试用前面的可行解填充当前的。**

```java
    public int numSquares(int n) {
        int[] dp = new int[n + 1]; // 默认初始化值都为0
        for (int i = 1; i <= n; i++) {
            dp[i] = i; // 最坏的情况就是每次+1
            for (int j = 1; i - j * j >= 0; j++) {
                // 尝试用前面的可行解填充当前的
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1); 
            }
        }
        return dp[n];
    }
```

其他方法：BFS，按层级遍历，找到的第一个就是最短的。注意用visited数组避免重复计算。

```java
    public int numSquares(int n) {
        Queue<Integer> queue = new LinkedList<>();
        HashSet<Integer> visited = new HashSet<>();
        int level = 0;
        queue.add(n);
        while (!queue.isEmpty()) {
            int size = queue.size();
            level++; // 开始生成下一层
            for (int i = 0; i < size; i++) {
                int cur = queue.poll();
                //依次减 1, 4, 9... 生成下一层的节点
                for (int j = 1; j * j <= cur; j++) {
                    int next = cur - j * j;
                    if (next == 0) {
                        return level;
                    }
                    if (!visited.contains(next)) {
                        queue.offer(next);
                        visited.add(next);
                    }
                }
            }
        }
        return -1;
    }
```







### [983. 最低票价](https://leetcode-cn.com/problems/minimum-cost-for-tickets/)

Difficulty: **中等**


在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 `days` 的数组给出。每一项是一个从 `1` 到 `365` 的整数。

火车票有三种不同的销售方式：

*   一张为期一天的通行证售价为 `costs[0]` 美元；
*   一张为期七天的通行证售价为 `costs[1]` 美元；
*   一张为期三十天的通行证售价为 `costs[2]` 美元。

通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。

返回你想要完成在给定的列表 `days` 中列出的每一天的旅行所需要的最低消费。

**示例 1：**

```
输入：days = [1,4,6,7,8,20], costs = [2,7,15]
输出：11
解释： 
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
```

**示例 2：**

```
输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
输出：17
解释：
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 
在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。
在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 
你总共花了 $17，并完成了你计划的每一天旅行。
```

**提示：**

1.  `1 <= days.length <= 365`
2.  `1 <= days[i] <= 365`
3.  `days` 按顺序严格递增
4.  `costs.length == 3`
5.  `1 <= costs[i] <= 1000`

**思路：类似[322. 零钱兑换](#322-零钱兑换)，用背包填充，cost数组填充dp数组，尝试用前面的可行解填充当前的。**

- 前面买7天或者30天的可能覆盖后面的，后面的结果依赖于前面的结果，因此dp当前值要回看之前值。

- dp[i]表示到了第i天的最低票价，dp[i] = Math.min(cost[0]+dp[i-1], cost[1]+dp[i-7], cost[2]+dp[i-30])，前提是dp[i-1]、dp[i-7]、dp[i-30]有效，如果无效，直接买一张1、7、30天票。

- 对于days中不存在的天数，不需要买票，最低票价等于前一天的最低票价。dp[i] = dp[i-1]

```java
	public int mincostTickets(int[] days, int[] costs) {
        //dp[i]表示到了第i天的最低票价
        int[] dp = new int[days[days.length - 1] + 1];

        //base case: 第0天一定不用买票 则花费0元
        dp[0] = 0;
        //标记一下需要买票的日子
        for (int day : days) {
            dp[day] = Integer.MAX_VALUE;
        }

        for (int i = 1; i < dp.length; i++) {
            //不需要买票
            if (dp[i] == 0) {
                //不需要出行的时候就是前一天花的钱
                dp[i] = dp[i - 1];
                continue;
            }
            //当天需要买票
            int n1 = dp[i - 1] + costs[0];
            //7天前能到达，就用7天前+今天新买。到达不了，就今天直接买一张7天票。
            int n2 = i > 7 ? dp[i - 7] + costs[1] : costs[1];
            //30天与7天 同理
            int n3 = i > 30 ? dp[i - 30] + costs[2] : costs[2];

            dp[i] = Math.min(n1, Math.min(n2, n3));
        }
        //最后一天花费多少钱
        return dp[days[days.length - 1]];
    }
```

